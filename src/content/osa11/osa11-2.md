---
title: "Poikkeukset"
nav_order: 112
hidden: false
---

# Poikkeukset eli Exceptions

Kun ohjelman suoritus päättyy virheeseen, **heitetään poikkeus** (englanniksi **throw exception**). Esimerkiksi ohjelma on voinut kutsua metodia, jolle annetaan null-viite ja **NullReferenceException** heitetään, tai ohjelma on voinut yrittää viitata taulukon ulkopuolelle ja **ArgumentOutOfRangeException** heitetään jne.

Joihinkin poikkeuksiin meidän tulisi aina varautua, kuten tiedoston lukemisen yhteydessä tai ongelmiin verkkoyhteyden kanssa. Ajonaikaisiin poikkeuksiin, kuten NullReferenceException, meidän ei tarvitse varautua etukäteen. C# kertoo aina, jos koodissasi on lause tai lauseke, joka voi heittää poikkeuksen, johon sinun tulee varautua.

## Poikkeusten käsittely

Voimme käyttää **try {} catch (Exception e) {}** -lohkorakennetta poikkeusten käsittelyyn. Avainsana **try** aloittaa lohkon, joka sisältää koodia, joka *saattaa* heittää poikkeuksen. Mitä tapahtuu, jos poikkeus heitetään try-lohkossa, määritellään avainsanan **catch** aloittamassa lohkossa. Avainsanan **catch** jälkeen tulee käsiteltävän poikkeuksen tyyppi, esimerkiksi "kaikki poikkeukset" **catch (Exception e)**.


```cpp
try 
{
  // koodia, joka saattaa heittää poikkeuksen
} catch (Exception e) 
{
  // koodilohko suoritetaan, jos poikkeus heitetään
}
```

Otamme poikkeuksesta kopin, (englanniksi **catch**), koska poikkeuksen aiheuttaminen on tietotekniikan termein poikkeuksen heittäminen (englanniksi "**throw**ing an exception").

Kuten yllä mainittu, meidän ei tarvitse varautua ajonaikaisiin poikkeuksiin, kuten NullReferenceException. Meidän ei tarvitse käsitellä näitä poikkeuksia, joten ohjelman suoritus pysähtyy, jos virhe aiheuttaa poikkeuksen heittämisen. Seuraavaksi katsomme yhtä tällaista tilannetta, merkkijonojen muuttamista kokonaisluvuiksi.

Olemme käyttäneet **Convert.ToInt32** -metodia aiemmin. Metodi heittää **FormatException** -poikkeuksen, jos sille annettua merkkijonoa ei voida muuttaa kokonaisluvuksi.

```cpp
Console.WriteLine("Give a number:");
int number = Convert.ToInt32(Console.ReadLine());
```

```console
Give a number:
> hotPotato
Unhandled exception. System.FormatException: Input string was not in a correct format.
   at System.Number.ThrowOverflowOrFormatException(ParsingStatus status, TypeCode type)
   at System.Number.ParseInt32(ReadOnlySpan`1 value, NumberStyles styles, NumberFormatInfo info)
   at System.Convert.ToInt32(String value)
   at Exercise001.Program.Main(String[] args) in [. . .]]/Program.cs:line 12
```

Yllä oleva ohjelma heittää poikkeuksen, jos käyttäjän syöte ei ole kelvollinen kokonaisluku. Poikkeus aiheuttaa ohjelman suorituksen pysähtymisen.

Käsitellään poikkeus. Käärimme metodin kutsun, joka saattaa heittää poikkeuksen, try-lohkoon ja poikkeuksen heittämisen jälkeen suoritettavan koodin catch-lohkoon.

```cpp
Console.WriteLine("Give a number:");
int number = 0;
try
{
  number = Convert.ToInt32(Console.ReadLine());
}
catch (Exception e)
{
  Console.WriteLine(e.Message);
}
```

```console
Give a number:
> potato
Input string was not in a correct format.
```

Kuten nähdään, käytimme myös **Exception** -luokan ominaisuutta. Kaikilla poikkeuksilla on viesti, ja sen voi käyttää **exception.Message** -ominaisuudella. Yritä löytää viesti poikkeuksesta, jota emme yllä olevassa esimerkissä käsitelleet.

Koodi catch-lohkossa suoritetaan heti, jos try-lohkossa oleva koodi heittää poikkeuksen. Voimme todistaa tämän lisäämällä tulostuksen **Convert.ToInt32** -metodin kutsun jälkeen try-lohkossa.

```cpp
Console.WriteLine("Give a number:");
int number = 0;
try
{
  number = Convert.ToInt32(Console.ReadLine());
  Console.WriteLine("Good job!");
}
catch (Exception e)
{
  Console.WriteLine(e.Message);
}
```

```console
Give a number:
> 12
Good job!
```

```console
Give a number:
> potato
Input string was not in a correct format.
```

Käyttäjän syöte, merkkijono "potato", annetaan **Convert.ToInt32** -metodille parametrina. Metodi heittää poikkeuksen, jos merkkijonoa ei voida muuttaa kokonaisluvuksi. Huomaa, että koodi catch-lohkossa suoritetaan vain, jos poikkeus heitetään.

Tehdään kokonaislukumuunnoksesta hieman hyödyllisempi. Muutetaan se metodiksi, joka pyytää käyttäjältä kokonaislukua, kunnes käyttäjä antaa kelvollisen kokonaisluvun. Suoritus pysähtyy vasta, kun käyttäjä antaa kelvollisen kokonaisluvun.


```cpp
public static void Main(string[] args)
  {
    ReadNumber();
  }

public static int ReadNumber()
{
  while (true)
  {
    Console.Write("Give a number: ");
    try
    {
      int readNumber = Convert.ToInt32(Console.ReadLine());
      return readNumber;
    }
    catch (Exception e)
    {
      Console.WriteLine(e.Message);
    }
  }
}
```

```console
Give a number: hotPotato
Input string was not in a correct format.
Give a number: Normal potato
Input string was not in a correct format.
Give a number: Spicy potato
Input string was not in a correct format.
Give a number: 12
```

## Tiedostovirheiden käsittely

Yleinen käyttötapaus try-catchille on tiedostojen lukeminen ja kirjoittaminen. Tähän asti olemme luottaneet koodimme ja kirjoittamiemme tiedostopolkujen olevan oikein. Mutta mitä tapahtuu, jos tiedostoa ei ole olemassa? Katsotaanpa.

```cpp
string text = File.ReadAllText("fileDoesNotExist.txt");
Console.WriteLine(text);
```

<Note>
Huomaa, alla olevassa esimerkissä [. . .] on käytetty piilottamaan tiedoston koko polku. Todellisissa poikkeuksissa olisi täysi tiedostopolku.
</Note>

```console
Unhandled exception. System.IO.FileNotFoundException: Could not find file '[. . .]/fileDoesNotExist.txt'.
File name: '[. . .]/fileDoesNotExist.txt'
   at Interop.ThrowExceptionForIoErrno(ErrorInfo errorInfo, String path, Boolean isDirectory, Func`2 errorRewriter)
   at Microsoft.Win32.SafeHandles.SafeFileHandle.Open(String path, OpenFlags flags, Int32 mode)
   at System.IO.FileStream.OpenHandle(FileMode mode, FileShare share, FileOptions options)
   at System.IO.FileStream..ctor(String path, FileMode mode, FileAccess access, FileShare share, Int32 bufferSize, FileOptions options)
   at System.IO.StreamReader.ValidateArgsAndOpenPath(String path, Encoding encoding, Int32 bufferSize)
   at System.IO.StreamReader..ctor(String path, Encoding encoding, Boolean detectEncodingFromByteOrderMarks)
   at System.IO.File.InternalReadAllText(String path, Encoding encoding)
   at System.IO.File.ReadAllText(String path)
   at Exercise001.Program.Main(String[] args) in [. . .]/Program.cs:line 12
```

Saamme aikamoisen kutsupinon, mutta tärkeintä on, että saamme **FileNotFoundException**. Kopataan se kiinni.

```cpp
try
{
  string text = File.ReadAllText("fileDoesNotExist.txt");
  Console.WriteLine(text);
}
catch (Exception e)
{
  Console.WriteLine(e.Message);
}
```

```console
Could not find file '[. . .]/fileDoesNotExist.txt'.
```

Nyt meillä on paljon merkityksellisempi virhe, mutta myöskään ohjelmamme ei kaatunut. Kokeillaan vielä kerran tiedostolla, joka on olemassa. Käytän "text.txt" -tiedostoa ja tulostan sen sisällön.

```cpp
try
{
  string text = File.ReadAllText("text.txt");
  Console.WriteLine(text);
}
catch (Exception e)
{
  Console.WriteLine(e.Message);
}
```

```console
This is a line
This is second line
This is 3rd
This includes a double, 3.25
This has "quotes"
```

Nyt tiedostomme on luettu, koodi try-lohkossa on suoritettu ja catch-lohkoa ei suoritettu, koska try-ehto toimi.

## Vastuun siirtäminen


Methods and constructors can throw exceptions. There are roughly two categories of exceptions. There are exceptions we have to handle, and exceptions we do not have to handle. We can handle exceptions by wrapping the code into a **try-catch** block or *throwing them out of the method*.

The code below reads the file given to it as a parameter line by line. Reading a file can throw an exception -- for example the file might not exist or the program does not have read rights to the file. This kind of exception has to be handled. We handle the exception by wrapping the code into a try-catch block. In this example we do not really care about the exception, but we do print a message to the user about it.

```cpp
public static void Main(string[] args)
{
  ReadLines("text.txt").ForEach(Console.WriteLine);
}


public static List<string> ReadLines(string fileName)
{
  List<string> list = new List<string>();
  try
  {
    string[] lines = File.ReadAllLines(fileName);
    list = new List<string>(lines);
  }
  catch (Exception e)
  {
    Console.WriteLine(e.Message);
  }
  return list;
}
```

A programmer can also leave the exception unhandled and shift the responsibility for handling it to whomever calls the method. We can shift the responsibility of handling an exception forward by throwing the exception out of a method. Notice on throwing an exception forward **throw new *ExceptionType*** is added in the method.

```cpp
public static void Main(string[] args)
{
  try
  {
    ReadLines("nonExistingFile.txt").ForEach(Console.WriteLine);
  }
  catch (Exception e)
  {
    Console.WriteLine("Caught in Main!");
  }
}


public static List<string> ReadLines(string fileName)
{
  List<string> list = new List<string>();
  if (!File.Exists(fileName))
  {
    throw new System.IO.FileNotFoundException();
  }
  string[] lines = File.ReadAllLines(fileName);
  list = new List<string>(lines);

  return list;
}
```

```console
Caught in Main!
```


## Throwing exceptions

In the previous topic, we already threw our first exception. Let's look into that a little deeper.

The throw command throws an exception. For example a **FormatException** can be done with command throw new FormatException(). The following code always throws an exception.

```cpp
public static void Main(string[] args)
{
  throw new FormatException();
}
```

```console
Unhandled exception. System.FormatException: One of the identified items was in an invalid format.
[. . .]
```

One exception which the user does not have to prepare for is **ArgumentException**. The ArgumentException tells the user that the values given to a method or a constructor as parameters are wrong. It can be used when we want to ensure certain parameter values.

Lets create class Grade. It gets a integer representing a grade as a constructor parameter.

```cpp
namespace Exercise001
{
  public class Grade
  {
    public int grade { get; }

    public Grade(int grade)
    {
      this.grade = grade;
    }
  }
}
```

We want that the grade fills certain criteria. The grade has to be an integer between 0 and 5. If it is something else, we want to throw an exception. Let's add a conditional statement to the constructor, which checks if the grade fills the criteria. If it does not, we throw the **ArgumentException** with **throw new ArgumentException("Grade must be between 0 and 5.");**.

```cpp
namespace Exercise001
{
  using System;
  public class Grade
  {
    public int grade { get; }

    public Grade(int grade)
    {
      if (grade < 0 || grade > 5)
      {
        throw new ArgumentException("Grade must be between 0 and 5.");
      }
      this.grade = grade;
    }
  }
}
```

Let's try this in action

```cpp
Grade grade = new Grade(3);
Console.WriteLine(grade.grade);

Grade illegalGrade = new Grade(22);
// exception happens, execution will not continue from here
```

```console
3
Unhandled exception. System.ArgumentException: Grade must be between 0 and 5.
   [. . .]
```

Exceptions which must be handled are exceptions which are checked for during compilation. Due to this, some exceptions have to be prepared for with a **try-catch** block or by throwing them out of a method with a throws attribute in a method declaration. For example exceptions related to handling files, **IOException** and **FileNotFoundException**, are this kind of exceptions.

Some exceptions are not checked for during compilation. They can be thrown during execution. These kinds of exceptions do not have to be handled with a try-catch block. For example **ArgumentException** and **NullReferenceException** are this kind of exceptions.

<Note>
Now we are able to throw our own custom exceptions, which can be caught just like any other exception.
</Note>

## Details of the exception

A catch block defines which exception to prepare for with catch \(*Exception e*\). The details of the exception are saved to the **e** variable.

```cpp
try {
    // program code which might throw an exception
} catch (Exception e) {
    // details of the exception are stored in the variable e
}
```

We have already used the property **Message**. In it is stored the message that describes the exception. Another useful property is **StackTrace**, which gives us a string representation of the immediate frames on the call stack.

```console
Unhandled exception. System.ArgumentException: Grade must be between 0 and 5.
   at Exercise001.Grade..ctor(Int32 grade) in [. . .]]/Grade.cs:line 14
   at Exercise001.Program.Main(String[] args) in []. . .]/Program.cs:line 14
```

We read a stack trace from the bottom up. At the bottom is the first call, so the execution of the program has begun from the **Main()** method for the **Program** class. Line 14 of the Main method was used to create the new Grade object, with illegal parameters. Line 14 of the Grade class is the constructor, and it has now thrown and **ArgumentException**. The details of an exception are very useful when trying to pinpoint where an error happens.



# Tehtävät

<Exercise title={'003 ArgumentException'}>

Let's practise a little parameter validation with the **ArgumentException** exception. There is a class called Person in the exercise:

* Osa 1

The constructor of the class **Person** should ensure that the name given as the parameter is not null, empty, or over 40 characters in length. If these conditions are not met, the constructor should throw an **ArgumentException**.

* Osa 2

In the contsructor, the age should between 0 and 120. If these conditions are not met, the constructor should throw an **ArgumentException**.

</Exercise>

<Exercise title={'004 Sensors and Temperature'}>


We have the following interface at our disposal:

```cpp
namespace Exercise004
{
  public interface ISensor
  {
    bool IsOn();    // returns true if the sensor is on
    void SetOn();      // sets the sensor on
    void SetOff();     // sets the sensor off
    int Read();        // returns the value of the sensor if it's on
                       // if the sensor is not on throw a IllegalStateException
  }
}
```

* Osa 1

Create a class called **StandardSensor** that implements the interface ISensor.

A standard sensor is always on. Calling the methods **SetOn** and **SetOff** has no effect. The StandardSensor must have a constructor that takes one integer parameter. The method call Read returns the number that was given to the constructor.

An example:

```cpp
StandardSensor ten = new StandardSensor(10);
StandardSensor minusFive = new StandardSensor(-5);

Console.WriteLine(ten.Read());
Console.WriteLine(minusFive.Read());

Console.WriteLine(ten.IsOn());
ten.SetOff();
Console.WriteLine(ten.IsOn());
```

Sample output

```console
10
-5
true
true
```
* Osa 2

Create a class **TemperatureSensor** that implements the ISensor interface.

* The constructor takes no parameters.
* At first a temperature sensor is off. 
* When the method Read is called and the sensor is on, the sensor randomly chooses an integer in the range -30...30 and returns it. 
* If the sensor is off, the method Read throws an **InvalidOperationException**.

An example:

```cpp
TemperatureSensor temperatureSensor = new TemperatureSensor();
temperatureSensor.SetOn();
Console.WriteLine(temperatureSensor.Read());
```

```console
23
```

</Exercise>