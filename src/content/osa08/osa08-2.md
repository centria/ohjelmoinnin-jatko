---
title: "Olioiden samankaltaisuus"
nav_order: 82
hidden: false
---

Kerrataan vielä **Equals**-metodi, jolla olioita vertaillaan, ja tutustutaan **GetHashCode**-metodiin, jolla tehdään likimääräisiä vertailuja.

## Metodi yhdenvertaisuuden tarkasteluun - "Equals"


[**Equals metodi**](https://learn.microsoft.com/en-us/dotnet/api/system.object.Equals?view=net-6.0) oletusarvoisesti tarkastaa, onko parametrina annetun olion viite sama kuin sen johon sitä verrataan. Toisinsanoen, oletuskäyttäytyminen tarkastaa, ovatko kaksi oliota samat. Jos viite on sama, metodi palauttaa true, muuten false.

Tätä voidaan havainnollistaa seuraavalla esimerkillä. Book-luokalla ei ole omaa toteutusta Equals-metodille, joten se turvautuu C#:n tarjoamaan oletustoteutukseen.


```cpp
Book bookObject = new Book("Book object", 2000, "...");
Book anotherBookObject = bookObject;

if (bookObject.Equals(anotherBookObject))
{
  Console.WriteLine("The books were the same");
}
else
{
  Console.WriteLine("The books weren't the same");
}

// nyt luodaan uusi olio, jolla on samat sisällöt, mutta joka on silti oma olionsa
anotherBookObject = new Book("Book object", 2000, "...");

if (bookObject.Equals(anotherBookObject))
{
  Console.WriteLine("The books were the same");
}
else
{
  Console.WriteLine("The books weren't the same");
}
```

```console
The books were the same
The books weren't the same
```

Kirjojen sisäinen rakenne (eli niiden olioiden instanssimuuttujien arvot) on sama, mutta vain ensimmäinen vertailu tulostaa "The books were the same". Tämä johtuu siitä, että viitteet ovat ensimmäisessä tapauksessa samat, eli olio vertaa itseään itseensä. Toisessa vertailussa on kyse kahdesta eri oliosta, vaikka muuttujien arvot olisivatkin samat.

Jos haluamme vertailla omia luokkiamme Equals-metodilla, se täytyy määritellä luokan sisälle. Luotu metodi ottaa parametrina Object-tyyppisen viitteen, joka voi olla mikä tahansa olio. Vertailussa ensin katsotaan viitteet. Tämän jälkeen tarkastetaan parametrina annetun olion tyyppi instanceof-operaatiolla - jos olion tyyppi ei vastaa omaa luokkaa, olio ei voi olla sama. Luodaan tämän jälkeen versio oliosta, joka on samaa tyyppiä kuin oma luokkamme, jonka jälkeen vertaillaan olioiden muuttujia keskenään.


```cpp
public override bool Equals(object compared)
{
  // jos oliot ovat samassa sijainnissa, ne ovat samat
  if (this == compared)
  {
    return true;
  }

  // jos verrattava olio on null tai ei ole tyyppiä Book, oliot eivät ole samat
  if ((compared == null) || !this.GetType().Equals(compared.GetType()))
  {
    return false;
  }
  else
  {
    // muunnetaan olio Book-tyyppiseksi
    Book comparedBook = (Book)compared;

    // jos olioiden muuttujien arvot ovat samat, oliot ovat samat
    return this.name == comparedBook.name && this.published == comparedBook.published && this.content == comparedBook.content;
  }
}
```

Alla Book-luokka kokonaisuudessaan.

```cpp
namespace Exercise001
{
  public class Book
  {
    public string name { get; set; }
    public string content { get; set; }
    public int published { get; set; }

    public Book(string name, int published, string content)
    {
      this.name = name;
      this.published = published;
      this.content = content;
    }

    public override string Tostring()
    {
      return "Name: " + this.name + " (" + this.published + ")\n"
          + "Content: " + this.content;
    }

    public override bool Equals(object compared)
    {
      if (this == compared)
      {
        return true;
      }
      if ((compared == null) || !this.GetType().Equals(compared.GetType()))
      {
        return false;
      }
      else
      {
        Book comparedBook = (Book)compared;
        return this.name == comparedBook.name && 
        this.published == comparedBook.published && 
        this.content == comparedBook.content;
      }
    }
  }
}
```

Nyt kirjojen vertailu palauttaa **true** jos kirjojen instanssimuuttujat ovat samat.


```cpp
Book bookObject = new Book("Book object", 2000, "...");
Book anotherBookObject = new Book("Book object", 2000, "...");

if (bookObject.Equals(anotherBookObject))
{
  Console.WriteLine("The books were the same");
}
else
{
  Console.WriteLine("The books weren't the same");
}
```

```console
Book.cs(3,16): warning CS0659: 'Book' overrides Object.Equals(object o) but does not override Object.GetHashCode() [/mnt/c/Users/HeikkiHei/Documents/coding-exercises/Exercise001/Exercise001.csproj]

The books were the same
```

Saamme myös hyvin tutun varoituksen. Vihdoin tässä osiossa teemme jotain asian eteen.

Myös **List** käyttää sisäisesti Equals-metodia. Jos emme määrittele Equals-metodia omiin olioihimme, Listin sisäinen toteutus ei toimi oikein. Kokeile alla olevaa koodia kahdella Book-luokalla, joista toisessa on määritelty Equals-metodi ja toisessa ei, niin huomaat eron.


```cpp
List<Book> books = new List<Book>();
Book bookObject = new Book("Book Object", 2000, "...");
books.Add(bookObject);

if (books.Contains(bookObject))
{
  Console.WriteLine("Book Object was found.");
}

bookObject = new Book("Book Object", 2000, "...");

if (!books.Contains(bookObject))
{
  Console.WriteLine("Book Object was not found.");
}
```

Tämä riippuvuus oletustoteutuksista, kuten Equals, on itseasiassa syy sille, miksi C# vaatii, että Listiin ja Dictionaryyn lisättävät muuttujat ovat viittausmuuttujia. Jokaisen viittausmuuttujan mukana tulee oletustoteutuksia, kuten Equals, jolloin Listin sisäistä toteutusta ei tarvitse muuttaa, kun lisätään eri tyyppisiä muuttujia.

## Vertailun likimääräisyys hakemistoissa

Equals-metodin lisäksi, metodia **GetHashCode** voidaan käyttää samankaltaisuuden likimääräiseen vertailuun. Metodi luo oliosta "hash-koodin", eli numeron, joka kertoo hieman olioiden sisällöstä. Jos kahdella oliolla on sama hash-arvo, ne voivat olla samat. Toisaalta, jos kahdella oliolla on eri hash-arvot, ne eivät voi olla samat.

Hash-koodeja käytetään esimerkiksi hakemistoissa. Hakemiston sisäinen rakenne perustuu siihen, että avain-arvo -parit tallennetaan taulukkoon joka perustuu avainten hash-arvoihin. Jokainen taulukon indeksi osoittaa listaan. Hash-arvo määrittää indeksin, jolloin listaan osoittava indeksi on tiedossa. Tämän jälkeen listaa käydään läpi, kunnes avain löytyy (vertailu tehdään Equals-metodilla). Tällä tavalla hakemistoa ei tarvitse käydä läpi kokonaan, vaan vain pieni osa avaimista.

Tähän mennessä olemme käyttäneet vain merkkijono-olioita hakemiston avaimina, joilla on valmiiksi toteutettu GetHashCode-metodi. Luodaan esimerkki, jossa näin ei ole. Jatkamme kirjoilla ja pidämme kirjaa lainassa olevista kirjoista. Kirjat pidetään hakemistossa, jonka avain on kirja ja arvo on merkkijono, joka kertoo lainaajan nimen.

```cpp
Dictionary<Book, string> borrowers = new Dictionary<Book, string>();

Book bookObject = new Book("Book Object", 2000, "...");
borrowers.Add(bookObject, "Pekka");
borrowers.Add(new Book("Test Driven Development", 1999, "..."), "Arto");

Console.WriteLine(borrowers[bookObject]);
Console.WriteLine(borrowers[new Book("Book Object", 2000, "...")]);
Console.WriteLine(borrowers[new Book("Test Driven Development", 1999, "...")]);
```

```console
Pekka
Unhandled exception. System.Collections.Generic.KeyNotFoundException: The given key 'Name: Book Object (2000) 
[. . .]
```

Saamme virheen, kun toisessa Console.WriteLine:ssa luotu olio ei vastaa mitään avainta (eikä kolmannessakaan, mutta ohjelma lopettaa ensimmäiseen virheeseen).


We find the borrower when searching for the same object that was given as a key to the dictionarys's Add method. However, when searching by the exact same book but with a different object,a borrower isn't found, and we get the error instead. The reason lies in the default implementation of the GetHashCode method in the Object class. The default implementation creates a HashCode value based on the object's reference, which means that books having the same content that are nonetheless different objects get different results from the GetHashCode method. As such, the object is not being searched for in the right place.

For the Dictionary to work in the way we want it to, that is, to return the borrower when given an object with the correct content (not necessarily the same object as the original key), the class that's the key must overwrite the GetHashCode method in addition to the Equals method. The method must be overwritten so that it gives the same numerical result for all objects with the same content. Also, some objects with different contents may get the same result from the GetHashCode method. However, with the Dictionary's performance in mind, it is essential that objects with different contents get the same hash value as rarely as possible.

We've previously used string objects as Dictionary keys, so we can deduce that the string class has a well-functioning GetHashCode implementation of its own. We'll Delegate, i.e., transfer the computational responsibility to the string object.

```cpp
public override int GetHashCode()
{
  return this.name.GetHashCode();
}
```

The above solution is quite good. However, if name is null, we see a NullReferenceException error. Let'fix this by defining a condition: if the value of the name variable is null, we'll return the year of publication as the hash value.

```cpp
public override int GetHashCode()
{
  if (this.name == null)
  {
    return this.published;
  }
  return this.name.GetHashCode();
}
```

Now, all of the books that share a name are bundleded into one group. Let's improve it further so that the year of publiciation is also taken into account in the hash value calculation that's based on the book title.

```cpp
public override int GetHashCode()
{
  if (this.name == null)
  {
    return this.published;
  }
  return this.published + this.name.GetHashCode();
}
```

It's now possible to use the book as the hash map's key. This way the problem we faced earlier gets solved and the book borrowers are found:

```cpp
Dictionary<Book, string> borrowers = new Dictionary<Book, string>();

Book bookObject = new Book("Book Object", 2000, "...");
borrowers.Add(bookObject, "Pekka");
borrowers.Add(new Book("Test Driven Development", 1999, "..."), "Arto");

Console.WriteLine(borrowers[bookObject]);
Console.WriteLine(borrowers[new Book("Book Object", 2000, "...")]);
Console.WriteLine(borrowers[new Book("Test Driven Development", 1999, "...")]);
```

Prints

```console
Pekka
Pekka
Arto
```

**Let's revise the ideas once more:** for a class to be used as a Dictionary's key, we need to define for it:

* method Equals , so that all equal or apporiximately equal objects cause the comparison to return true and all false for all the rest
* method GetHashCode , so that as few objects as possible end up with the same hash value



# Tehtävät

<Exercise title={'006 Same Date'}>

The exercise template contains a class **SimpleDate**, which defines a date object based on a given day, month, and year. In this exercise you will expand the SimpleDate class with an equals method, which can tell if the dates are exactly the same.

* create a method **public override bool Equals(object compared)** for the SimpleDate class, which returns true if the date of the object passed to the method as a parameter is the same as the date of the object used to call the method.

* create a method **public override int GetHashCode()** for the SimpleDate class, which calculates a hash for the the SimpleDate object. Implement the calculation of the hash in way that there are as few similar hashes as possible between the years 1900 and 2100.

The Equals should work as follows:

```cpp      
SimpleDate d = new SimpleDate(1, 2, 2000);
Console.WriteLine(d.Equals("heh"));
Console.WriteLine(d.Equals(new SimpleDate(5, 2, 2012)));
Console.WriteLine(d.Equals(new SimpleDate(1, 2, 2000)));
```

```console
false
false
true
```

</Exercise>

<Exercise title={'007 Vehicle Registry'}>

* Section 1

European license plates have to parts, a two letter country code and a nationally unique license number. The license number is made up of numbers and characters. License plates are represented by the following class:

```cpp
public class LicensePlate
{
  private string liNumber;
  private string country;

  public LicensePlate(string country, string liNumber)
  {
    this.liNumber = liNumber;
    this.country = country;
  }


  public override string ToString()
  {
    return country + " " + liNumber;
  }
}
```

We want to be able to save the license plates in e.g Lists and to use them as keys in a Dictionary. Which, as explained above, means that the **Equals** and **GetHashCode** methods need to be overwritten, or they won't work as intended. Implement the methods Equals and GetHashCode for the LicensePlate class.

Example program:

```cpp
LicensePlate li1 = new LicensePlate("FI", "ABC-123");
LicensePlate li2 = new LicensePlate("FI", "UXE-465");
LicensePlate li3 = new LicensePlate("D", "B WQ-431");

List<LicensePlate> finnishPlates = new List<LicensePlate>();
finnishPlates.Add(li1);
finnishPlates.Add(li2);

LicensePlate newLi = new LicensePlate("FI", "ABC-123");
if (!finnishPlates.Contains(newLi))
{
  finnishPlates.Add(newLi);
}
Console.WriteLine("Finnish: ");
foreach (LicensePlate plate in finnishPlates)
{
  Console.WriteLine(plate);
}

Dictionary<LicensePlate, string> owners = new Dictionary<LicensePlate, string>();
owners.Add(li1, "Arto");
owners.Add(li3, "Jürgen");

Console.WriteLine("Owners:");
Console.WriteLine(owners[new LicensePlate("FI", "ABC-123")]);
Console.WriteLine(owners[new LicensePlate("D", "B WQ-431")]);
```

```console
Finnish: 
FI ABC-123
FI UXE-465
Owners:
Arto
Jürgen
```

* Section 2

Implement the class **VehicleRegistry**, which has the following methods:

* **public bool Add(LicensePlate licensePlate, string owner)** assigns the owner it received as a parameter to car corresponding with the license plate received as a parameter. If the license plate didn't have an owner returns **true**. If the license already had an owner attached, the method returns **false and does nothing**.

* **public string Get(LicensePlate licensePlate)** returns the owner of the car corresponding to the license plate received as a parameter. If the car isn't in the registry, returns an error message (of your choice).

* **public bool Remove(LicensePlate licensePlate)** removes the license plate and attached data from the registry. Returns **true** if removed successfully and **false** if the license plate wasn't in the registry.

* **public void PrintLicensePlates()** prints the license plates in the registry.

* **public void PrintOwners()** prints the owners of the cars in the registry. Each name should only be printed once, even if a particular person owns more than one car.

Now the program should work something like this:

```cpp
LicensePlate li1 = new LicensePlate("FI", "ABC-123");
LicensePlate li2 = new LicensePlate("FI", "UXE-465");
LicensePlate li3 = new LicensePlate("D", "B WQ-431");
LicensePlate li4 = new LicensePlate("D", "B WQ-432");
LicensePlate li5 = new LicensePlate("D", "B WQ-433");

VehicleRegistry register = new VehicleRegistry();

register.Add(li1, "Arto");
register.Add(li2, "Arto");
register.Add(li3, "Jürgen");
register.Add(li4, "Jürgen");
register.Add(li5, "Jürgen");

Console.WriteLine("Plates:");
register.PrintLicensePlates();

Console.WriteLine("Owners:");
register.PrintOwners();
```

```console
Plates:
FI ABC-123
FI UXE-465
D B WQ-431
D B WQ-432
D B WQ-433
Owners:
Arto
Jürgen
```

<Note>In the printOwners method, you can create a list used for remembering the owners that were already printed. If an owner is not on the their name is printed and they are added to the list -- if an owner is on the list their name isn't printed.</Note>
</Exercise>
