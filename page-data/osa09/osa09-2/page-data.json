{
    "componentChunkName": "component---src-templates-docs-js",
    "path": "/osa09/osa09-2",
    "result": {"data":{"mdx":{"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Rajapinnat\",\n  \"nav_order\": 92,\n  \"hidden\": false\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar Note = makeShortcode(\"Note\");\nvar Exercise = makeShortcode(\"Exercise\");\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Voimme k\\xE4ytt\\xE4\\xE4 \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"rajapintoja\"), \" (englanniksi \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"interfaces\"), \") m\\xE4\\xE4ritt\\xE4m\\xE4\\xE4n luokkien k\\xE4ytt\\xE4ytymist\\xE4, eli sen metodeita. Rajapinnat m\\xE4\\xE4ritell\\xE4\\xE4n samalla tavalla kuin tavalliset C#-luokat, mutta niiden alussa k\\xE4ytet\\xE4\\xE4n \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"\\\"public interface I...\\\"\"), \" -sijaan \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"\\\"public class ... \\\"\"), \". Rajapinnat m\\xE4\\xE4rittelev\\xE4t k\\xE4ytt\\xE4ytymist\\xE4 metodien nimien ja paluuarvojen kautta. Ne eiv\\xE4t kuitenkaan aina sis\\xE4ll\\xE4 metodien varsinaisia toteutuksia. N\\xE4kyvyysattribuuttia rajapinnoissa ei merkit\\xE4 erikseen, vaan ne ovat aina public. Tutkitaan \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"IReadable\"), \"-rajapintaa, joka kuvaa luettavuutta.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"namespace Exercise001\\n{\\n  public interface IReadable\\n  {\\n    string Read();\\n  }\\n}\\n\")), mdx(Note, {\n    mdxType: \"Note\"\n  }, \"Huomaatko miten rajapinnan nimi alkaa isolla I-kirjaimella? T\\xE4m\\xE4 on C#:n nime\\xE4misk\\xE4yt\\xE4nt\\xF6, ja kaikkien rajapintojen tulisi alkaa isolla I-kirjaimella.\"), mdx(\"p\", null, \"Rajapinta IReadable m\\xE4\\xE4rittelee Read()-metodin, joka palauttaa string-tyyppisen olion. IReadable m\\xE4\\xE4rittelee tietyn k\\xE4ytt\\xE4ytymisen: esimerkiksi tekstiviesti tai s\\xE4hk\\xF6posti voisivat olla luettavia.\"), mdx(\"p\", null, \"Luokat jotka toteuttavat rajapinnan m\\xE4\\xE4rittelev\\xE4t miten rajapinnassa m\\xE4\\xE4ritellyt metodit toteutetaan. Luokka toteuttaa rajapinnan lis\\xE4\\xE4m\\xE4ll\\xE4 luokan nimen j\\xE4lkeen \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \":\"), \" (kaksoispisteen) ja rajapinnan nimen. Luodaan luokka \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"TextMessage\"), \", joka toteuttaa rajapinnan \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"IReadable\"), \".\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"namespace Exercise001\\n{\\n  public class TextMessage : IReadable\\n  {\\n    public string sender { get; }\\n    private string content;\\n\\n    public TextMessage(string sender, string content)\\n    {\\n      this.sender = sender;\\n      this.content = content;\\n    }\\n\\n    public string Read()\\n    {\\n      return this.content;\\n    }\\n  }\\n}\\n\")), mdx(\"p\", null, \"Koska luokka \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"TextMessage\"), \" toteuttaa rajapinnan \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"IReadable\"), \" (\", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"public class TextMessage : IReadable\"), \"), luokan t\\xE4ytyy sis\\xE4lt\\xE4\\xE4 toteutus metodille \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"public string Read()\"), \". Rajapinnan m\\xE4\\xE4rittelemien metodien toteutukset t\\xE4ytyy aina olla public-n\\xE4kyvyysm\\xE4\\xE4reell\\xE4, ja ovat oletuksena public.\"), mdx(\"p\", null, \"Kun luokka toteuttaa rajapinnan, se allekirjoittaa sopimuksen. Sopimus m\\xE4\\xE4rittelee, ett\\xE4 luokka toteuttaa rajapinnassa m\\xE4\\xE4ritellyt metodit. Jos n\\xE4it\\xE4 metodeja ei ole toteutettu luokassa, ohjelma ei toimi.\"), mdx(\"p\", null, \"Rajapinta m\\xE4\\xE4ritt\\xE4\\xE4 vain metodien nimet, parametrit ja paluuarvot. Rajapinnalla ei kuitenkaan ole sananvaltaa metodien sis\\xE4iseen toteutukseen. Metodien sis\\xE4inen toiminnallisuus on ohjelmoijan vastuulla.\"), mdx(\"p\", null, \"Tekstiviestiluokan lis\\xE4ksi, tehd\\xE4\\xE4n toinen luokka joka toteuttaa rajapinnan \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"IReadable\"), \". Luokka \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"EBook\"), \" on s\\xE4hk\\xF6inen kirja, joka sis\\xE4lt\\xE4\\xE4 kirjan nimen ja sivut. Kirjaa luetaan sivu kerrallaan, ja \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"public string Read()\"), \" -metodia kutsuttaessa palautetaan aina seuraava sivu merkkijonona.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"namespace Exercise001\\n{\\n  using System.Collections.Generic;\\n  public class EBook : IReadable\\n  {\\n    public string name { get; }\\n    private List<string> pages;\\n    private int pageNumber;\\n\\n    public EBook(string name, List<string> pages)\\n    {\\n      this.name = name;\\n      this.pages = pages;\\n      this.pageNumber = 0;\\n    }\\n\\n    public int Pages()\\n    {\\n      return this.pages.Count;\\n    }\\n\\n    public string Read()\\n    {\\n      string page = this.pages[this.pageNumber];\\n      NextPage();\\n      return page;\\n    }\\n\\n    private void NextPage()\\n    {\\n      this.pageNumber = this.pageNumber + 1;\\n      if (this.pageNumber % this.pages.Count == 0)\\n      {\\n        this.pageNumber = 0;\\n      }\\n    }\\n  }\\n}\\n\")), mdx(\"p\", null, \"Olioita voidaan luoda rajapinnan toteuttavista luokista aivan kuten tavallisista luokista. Niit\\xE4 k\\xE4ytet\\xE4\\xE4n my\\xF6s samalla tavalla, esimerkiksi List-tyypin tyyppin\\xE4.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"TextMessage message = new TextMessage(\\\"teacher\\\", \\\"It's going great!\\\");\\nConsole.WriteLine(message.Read());\\n\\nList<TextMessage> txtmsg = new List<TextMessage>();\\ntxtmsg.Add(new TextMessage(\\\"private number\\\", \\\"I hid the body.\\\"));\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"It's going great!\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"List<string> pages = new List<string>();\\npages.Add(\\\"Split your method into short, readable entities.\\\");\\npages.Add(\\\"Seperate the user-interface logic from the application logic.\\\");\\npages.Add(\\\"Always program a small part initially that solves a part of the problem.\\\");\\npages.Add(\\\"Practice makes the master. Try different out things for yourself and work on your own projects.\\\");\\n\\nEBook book = new EBook(\\\"Tips for programming.\\\", pages);\\n\\nint page = 0;\\nwhile (page < book.Pages())\\n{\\n  Console.WriteLine(book.Read());\\n  page = page + 1;\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"Split your method into short, readable entities.\\nSeperate the user-interface logic from the application logic.\\nAlways program a small part initially that solves a part of the problem.\\nPractice makes the master. Try different out things for yourself and work on your own projects.\\n\")), mdx(\"h2\", {\n    \"id\": \"rajapinnat-muuttujatyyppeinä\"\n  }, \"Rajapinnat muuttujatyyppein\\xE4\"), mdx(\"p\", null, \"Muuttujan tyyppi m\\xE4\\xE4ritell\\xE4\\xE4n aina sen esittelyss\\xE4. Tyyppej\\xE4 on kaksi, arvotyypit (int, double, ...) ja viittaus-tyypit (kaikki oliot). Olemme t\\xE4h\\xE4n asti k\\xE4ytt\\xE4neet olioiden tyyppin\\xE4 niiden luokkaa.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"string str = \\\"string-object\\\";\\nTextMessage message = new TextMessage(\\\"teacher\\\", \\\"many types for the same object\\\");\\n\")), mdx(\"p\", null, \"Olion tyyppi voi olla muutakin kuin sen luokka. Esimerkiksi, \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"EBook\"), \"-luokka, joka toteuttaa rajapintaa \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"IReadable\"), \" on aina my\\xF6s \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"IReadable\"), \"-tyyppinen. Samoin tekstiviestill\\xE4 on monia tyyppej\\xE4. Koska \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"TextMessage\"), \"-luokka toteuttaa rajapinnan \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"IReadable\"), \", sill\\xE4 on my\\xF6s \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"IReadable\"), \"-tyyppi oman luokkansa lis\\xE4ksi.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"TextMessage message = new TextMessage(\\\"teacher\\\", \\\"Something cool's about to happen\\\");\\nIReadable readable = new TextMessage(\\\"teacher\\\", \\\"The text message is IReadable!\\\");\\n\")), mdx(\"p\", null, \"Et voi kuitenkaan tehd\\xE4 n\\xE4in:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"List<string> pages = new List<string>();\\npages.Add(\\\"A method can call itself.\\\");\\n\\nIReadable book = new EBook(\\\"Introduction to Recursion\\\", pages);\\n\\nint page = 0;\\nwhile (page < book.Pages())\\n{\\n  Console.WriteLine(book.Read());\\n  page = page + 1;\\n} \\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"Program.cs(16,26): error CS1061: 'IReadable' does not contain a definition for 'Pages' and no accessible extension method 'Pages' accepting a first argument of type 'IReadable' could be found (are you missing a using directive or an assembly reference?) [. . .]\\n\\nThe build failed. Fix the build errors and run again.\\n\")), mdx(\"p\", null, \"Koska rajapinta \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"IReadable\"), \" ei sis\\xE4ll\\xE4 metodia \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Pages()\"), \" luokasta \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"EBook\"), \", yll\\xE4 oleva esimerkki ei toimi. Metodien periytyminen toimii vain yhteen suuntaan... T\\xE4m\\xE4 toimisi:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"List<IReadable> readingList = new List<IReadable>();\\n\\nreadingList.Add(new TextMessage(\\\"teacher\\\", \\\"never been programming before...\\\"));\\nreadingList.Add(new TextMessage(\\\"teacher\\\", \\\"gonna love it i think!\\\"));\\nreadingList.Add(new TextMessage(\\\"teacher\\\", \\\"give me something more challenging! :)\\\"));\\nreadingList.Add(new TextMessage(\\\"teacher\\\", \\\"you think i can do it?\\\"));\\nreadingList.Add(new TextMessage(\\\"teacher\\\", \\\"up here we send several messages each day\\\"));\\n\\n\\nList<string> pages = new List<string>();\\npages.Add(\\\"A method can call itself.\\\");\\n\\nreadingList.Add(new EBook(\\\"Introduction to Recursion.\\\", pages));\\n\\nforeach (IReadable readable in readingList)\\n{\\n  Console.WriteLine(readable.Read());\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"never been programming before...\\ngonna love it i think!\\ngive me something more challenging! :)\\nyou think i can do it?\\nup here we send several messages each day\\nA method can call itself.\\n\")), mdx(\"p\", null, \"Huomaa, ett\\xE4 vaikka \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"EBook\"), \"-luokasta periytyv\\xE4 \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"IReadable\"), \"-rajapinnan toteuttava luokka on aina rajapinnan tyyppinen, ei kaikki rajapinnan toteuttavat luokat ole \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"EBook\"), \"-tyyppisi\\xE4. Voit antaa \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"EBook\"), \"-luokasta luodun olion \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"IReadable\"), \"-tyyppiselle muuttujalle, mutta toisin p\\xE4in se ei onnistu ilman erillist\\xE4 tyyppimuunnosta.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"IReadable readable = new TextMessage(\\\"teacher\\\", \\\"TextMessage is Readable!\\\"); // toimii\\nTextMessage message = readable; // ei toimi\\n\\nTextMessage castMessage = (TextMessage)readable; // toimii jos, ja vain jos, readable on TextMessage-tyyppinen\\n\")), mdx(\"p\", null, \"Tyyppimuunnos onnistuu jos, ja vain jos, muuttuja on sit\\xE4 tyyppi\\xE4 mihin se muutetaan. Tyyppimuunnos ei ole hyvien k\\xE4yt\\xE4nteiden mukaista, ja yksi harvoista tilanteista joissa se on sallittua on \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Equals\"), \"-metodin toteutuksessa.\"), mdx(\"h2\", {\n    \"id\": \"rajapinnat-metodin-parametreina\"\n  }, \"Rajapinnat metodin parametreina\"), mdx(\"p\", null, \"Rajapintojen todelliset hy\\xF6dyt tulevat esiin kun niit\\xE4 k\\xE4ytet\\xE4\\xE4n metodin parametrina. Koska rajapintaa voidaan k\\xE4ytt\\xE4\\xE4 muuttujan tyypin m\\xE4\\xE4ritt\\xE4miseen, voidaan sit\\xE4 k\\xE4ytt\\xE4\\xE4 my\\xF6s metodin parametrin tyypin m\\xE4\\xE4ritt\\xE4miseen. Esimerkiksi, \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Printer\"), \"-luokan \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Print\"), \"-metodi saa parametrina \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"IReadable\"), \"-tyyppisen muuttujan.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"public class Printer\\n{\\n  public void Print(IReadable readable)\\n  {\\n    Console.WriteLine(readable.Read());\\n  }\\n}\\n\")), mdx(\"p\", null, \"Metodin \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Print\"), \" arvo on siin\\xE4, ett\\xE4 sille voidaan antaa parametrina mik\\xE4 tahansa \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"IReadable\"), \"-rajapinnan toteuttava luokka. Jos kutsuisimme metodia mik\\xE4 tahansa \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"IReadable\"), \"-rajapinnan toteuttavalla oliolla, metodi toimisi halutulla tavalla.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"TextMessage message = new TextMessage(\\\"ope\\\", \\\"Oh wow, this printer knows how to print these as well!\\\");\\n\\nList<string> pages = new List<string>();\\npages.Add(\\\"Values common to both {1, 3, 5} and {2, 3, 4, 5} are {3, 5}.\\\");\\nEbook book = new Ebook(\\\"Introduction to University Mathematics.\\\", pages);\\n\\nPrinter printer = new Printer();\\nprinter.Print(message);\\nprinter.Print(book);\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"Oh wow, this printer knows how to print these as well!\\nValues common to both {1, 3, 5} and {2, 3, 4, 5} are {3, 5}.\\n\")), mdx(\"p\", null, \"Luodaan uusi luokka \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"ReadingList\"), \", johon voidaan lis\\xE4t\\xE4 luettavia asioita. Luokalla on List-instanssimuuttuja, johon lis\\xE4tt\\xE4v\\xE4t luettavat asiat lis\\xE4t\\xE4\\xE4n. Lis\\xE4\\xE4minen tapahtuu \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Add\"), \"-metodilla, joka saa parametrinaan \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"IReadable\"), \"-tyyppisen olion.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"public class ReadingList\\n{\\n  private List<IReadable> readables;\\n\\n  public ReadingList()\\n  {\\n    this.readables = new List<IReadable>();\\n  }\\n\\n  public void Add(IReadable readable)\\n  {\\n    this.readables.Add(readable);\\n  }\\n\\n  public int ToRead()\\n  {\\n    return this.readables.Count;\\n  }\\n}\\n\")), mdx(\"p\", null, \"Lukulistat ovat yleens\\xE4 luettavissa, joten toteutetaan \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"ReadingList\"), \"-luokalle \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"IReadable\"), \"-rajapinta. \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Read\"), \"-metodi lukee kaikki lukulistassa olevat oliot, ja lis\\xE4\\xE4 ne palautettavaan merkkijonoon yksi kerrallaan.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"public class ReadingList : IReadable\\n{\\n  private List<IReadable> readables;\\n\\n  public ReadingList()\\n  {\\n    this.readables = new List<IReadable>();\\n  }\\n\\n  public void Add(IReadable readable)\\n  {\\n    this.readables.Add(readable);\\n  }\\n\\n  public int ToRead()\\n  {\\n    return this.readables.Count;\\n  }\\n\\n  public string Read()\\n  {\\n    string read = \\\"\\\";\\n\\n    foreach (IReadable readable in this.readables)\\n    {\\n      read = read + readable.Read() + \\\"\\\\n\\\";\\n    }\\n\\n    // kun lukulista on luettu, tyhjennet\\xE4\\xE4n se\\n    this.readables.Clear();\\n    return read;\\n  }\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"ReadingList jonisList = new ReadingList();\\njonisList.Add(new TextMessage(\\\"heikki\\\", \\\"have you written the tests yet?\\\"));\\njonisList.Add(new TextMessage(\\\"heikki\\\", \\\"have you checked the submissions yet?\\\"));\\n\\nConsole.WriteLine(\\\"Joni's to-read: \\\" + jonisList.ToRead());\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"Joni's to-read: 2\\n\")), mdx(\"p\", null, \"Koska \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"ReadingList\"), \" on tyyppi\\xE4 \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"IReadable\"), \", voimme lis\\xE4t\\xE4 \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"ReadingList\"), \"-olioita lukulistaan. Esimerkiss\\xE4 alla Jonilla on paljon luettavaa. Onneksi Verna tulee apuun ja lukee Jonin puolesta viestit.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"ReadingList jonisList = new ReadingList();\\nint i = 0;\\nwhile (i < 1000)\\n{\\n  jonisList.Add(new TextMessage(\\\"heikki\\\", \\\"did you test already?\\\"));\\n  i = i + 1;\\n}\\n\\nConsole.WriteLine(\\\"Joni's to-read: \\\" + jonisList.ToRead());\\nConsole.WriteLine(\\\"Delegating the reading to Verna\\\");\\n\\nReadingList vernasList = new ReadingList();\\nvernasList.Add(jonisList);\\nvernasList.Read();\\n\\nConsole.WriteLine();\\nConsole.WriteLine(\\\"Joni's to-read: \\\" + jonisList.ToRead());\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"Joni's to-read: 1000\\nDelegating the reading to Verna\\n\\nJoni's to-read: 0\\n\")), mdx(\"p\", null, \"Vernan lukulistan \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Read\"), \"-metodi k\\xE4y l\\xE4pi kaikki \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"IReadable\"), \"-rajapinnan toteuttavat oliot ja kutsuu niiden \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Read\"), \"-metodia. Kun \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Read\"), \"-metodia kutsutaan \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"vernasList\"), \"-oliolle, se k\\xE4y l\\xE4pi my\\xF6s Jonin lukulistan, joka on sis\\xE4llytetty Vernan lukulistaan. Jonin listaa k\\xE4yd\\xE4\\xE4n l\\xE4pi kutsumalla sen \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Read\"), \"-metodia. Jokaisen \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Read\"), \"-metodin kutsun j\\xE4lkeen lukulista tyhjennet\\xE4\\xE4n. T\\xE4ll\\xE4 tavalla Jonin lukulista tyhjenee Vernan lukiessa sit\\xE4.\"), mdx(\"p\", null, \"Kuten huomaat, ohjelma sis\\xE4lt\\xE4\\xE4 jo paljon viittauksia. On hyv\\xE4 idea piirt\\xE4\\xE4 ohjelman tila vaihe vaiheelta paperille ja hahmotella miten \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"vernasList\"), \"-olion \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Read\"), \"-metodin kutsu etenee!\"), mdx(\"h2\", {\n    \"id\": \"rajapinta-metodin-paluuarvona\"\n  }, \"Rajapinta metodin paluuarvona\"), mdx(\"p\", null, \"Luodaan muutama luokka ja rajapinta esimerkki\\xE4mme varten. Rajapintamme, \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"IStorable\"), \", m\\xE4\\xE4rittelee metodin \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Weight\"), \". Luokat \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"CD\"), \" ja \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Book\"), \" toteuttavat rajapinnan.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"public interface IStorable\\n{\\n  double Weight();\\n}\\n\")), mdx(\"p\", null, \"Luokat:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"public class CD : IStorable\\n{\\n  public string artist;\\n  public string name;\\n  public double weight;\\n  public int year;\\n  public CD(string artist, string name, int year)\\n  {\\n    this.artist = artist;\\n    this.name = name;\\n    this.weight = 0.1;\\n    this.year = year;\\n  }\\n\\n  public double Weight()\\n  {\\n    return this.weight;\\n  }\\n\\n  public override string ToString()\\n  {\\n    return this.artist + \\\" - \\\" + this.name + \\\" (\\\" + this.year + \\\")\\\";\\n  }\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"public class Book : IStorable\\n{\\n  public string author;\\n  public string name;\\n  public double weight;\\n  public Book(string author, string name, double weight)\\n  {\\n    this.author = author;\\n    this.name = name;\\n    this.weight = weight;\\n  }\\n\\n  public double Weight()\\n  {\\n    return this.weight;\\n  }\\n\\n  public override string ToString()\\n  {\\n    return this.author + \\\": \\\" + this.name;\\n  }\\n}\\n\")), mdx(\"p\", null, \"Voimme k\\xE4ytt\\xE4\\xE4 niit\\xE4 n\\xE4in:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"Book book1 = new Book(\\\"Fedor Dostojevski\\\", \\\"Crime and Punishment\\\", 2);\\nBook book2 = new Book(\\\"Robert Martin\\\", \\\"Clean Code\\\", 1);\\nBook book3 = new Book(\\\"Kent Beck\\\", \\\"Test Driven Development\\\", 0.5);\\n\\nCD cd1 = new CD(\\\"Pink Floyd\\\", \\\"Dark Side of the Moon\\\", 1973);\\nCD cd2 = new CD(\\\"Wigwam\\\", \\\"Nuclear Nightclub\\\", 1975);\\nCD cd3 = new CD(\\\"Rendezvous Park\\\", \\\"Closer to Being Here\\\", 2012);\\n\\nConsole.WriteLine(book1);\\nConsole.WriteLine(book2);\\nConsole.WriteLine(book3);\\nConsole.WriteLine(cd1);\\nConsole.WriteLine(cd2);\\nConsole.WriteLine(cd3);\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"Fedor Dostojevski: Crime and Punishment\\nRobert Martin: Clean Code\\nKent Beck: Test Driven Development\\nPink Floyd - Dark Side of the Moon (1973)\\nWigwam - Nuclear Nightclub (1975)\\nRendezvous Park - Closer to Being Here (2012)\\n\")), mdx(\"p\", null, \"T\\xE4m\\xE4 ei ole kovin mielenkiintoista, ja tied\\xE4mmekin jo t\\xE4m\\xE4n. Tehd\\xE4\\xE4n jotain mielenkiintoisempaa.\"), mdx(\"p\", null, \"Rajapintoja voidaan k\\xE4ytt\\xE4\\xE4 my\\xF6s metodin paluuarvona -- kuten mit\\xE4 tahansa \\\"tavallista\\\" muuttujatyyppi\\xE4. Seuraavassa esimerkiss\\xE4 on luokka \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Factory\"), \", joka osaa valmistaa erilaisia \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"IStorable\"), \"-rajapinnan toteuttavia olioita.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"public class Factory\\n{\\n\\n  public Factory()\\n  {\\n    // huomaa ettei ole tarvetta kirjoittaa tyhj\\xE4\\xE4 konstruktoria ilman\\n    // parametreja, jos luokalla ei ole muita konstruktoreita.\\n    // N\\xE4iss\\xE4 tapauksissa C# luo automaattisesti luokalle oletuskonstruktorin\\n    // joka on tyhj\\xE4 konstruktori ilman parametreja.\\n  }\\n\\n  public IStorable ProduceNew()\\n  {\\n    // Random-olioa k\\xE4ytet\\xE4\\xE4n arpomaan satunnaisia lukuja.\\n    Random ticket = new Random();\\n    // Numeron arvoalue on [0, 4[. Numero on 0, 1, 2 tai 3.\\n    int number = ticket.Next(0, 4);\\n\\n    if (number == 0)\\n    {\\n      return new CD(\\\"Pink Floyd\\\", \\\"Dark Side of the Moon\\\", 1973);\\n    }\\n    else if (number == 1)\\n    {\\n      return new CD(\\\"Wigwam\\\", \\\"Nuclear Nightclub\\\", 1975);\\n    }\\n    else if (number == 2)\\n    {\\n      return new Book(\\\"Robert Martin\\\", \\\"Clean Code\\\", 1);\\n    }\\n    else\\n    {\\n      return new Book(\\\"Kent Beck\\\", \\\"Test Driven Development\\\", 0.7);\\n    }\\n  }\\n}\\n\")), mdx(\"p\", null, \"Tehdasta voidaan k\\xE4ytt\\xE4\\xE4 tiet\\xE4m\\xE4tt\\xE4 tarkalleen mit\\xE4 erilaisia \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"IStorable\"), \"-rajapinnan toteuttavia luokkia on olemassa. Seuraavassa esimerkiss\\xE4 on luokka \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Packer\"), \", joka antaa listan asioita. Packer tiet\\xE4\\xE4 tehtaan, jota k\\xE4ytet\\xE4\\xE4n asioiden valmistamiseen.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"public class Packer\\n{\\n  private Factory factory;\\n\\n  public Packer()\\n  {\\n    this.factory = new Factory();\\n  }\\n\\n  public List<IStorable> GiveAListOfThings()\\n  {\\n    List<IStorable> list = new List<IStorable>();\\n\\n    int i = 0;\\n    while (i < 10)\\n    {\\n      IStorable newThing = factory.ProduceNew();\\n      list.Add(newThing);\\n\\n      i = i + 1;\\n    }\\n\\n    return list;\\n  }\\n}\\n\")), mdx(\"p\", null, \"Koska pakkaaja ei tied\\xE4 mit\\xE4 \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"IStorable\"), \"-rajapinnan toteuttavia luokkia on olemassa, voidaan uusia luokkia lis\\xE4t\\xE4 ilman ett\\xE4 pakkaajaa tarvitsee muuttaa. Seuraavassa esimerkiss\\xE4 luodaan uusi luokka \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"ChocolateBar\"), \", joka toteuttaa \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"IStorable\"), \"-rajapinnan. Tehdasta on muutettu niin, ett\\xE4 se osaa valmistaa my\\xF6s suklaapatukoita kirjojen ja cd-levyjen lis\\xE4ksi. Pakkaaja toimii ilman muutoksia uuden tehtaan kanssa.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"public class ChocolateBar : IStorable\\n{\\n  // Koska C# luo automaattisesti oletuskonstruktorin, ei meid\\xE4n tarvitse\\n\\n  public double Weight()\\n  {\\n    return 0.2;\\n  }\\n\\n  public override string ToString()\\n  {\\n    return \\\"Candybar, weight: \\\" + Weight();\\n  }\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"public class Factory\\n{\\n  public IStorable ProduceNew()\\n  {\\n    Random ticket = new Random();\\n    // kasvatetaan v\\xE4li\\xE4 yhdell\\xE4\\n    int number = ticket.Next(0, 5);\\n\\n    if (number == 0)\\n    {\\n      return new CD(\\\"Pink Floyd\\\", \\\"Dark Side of the Moon\\\", 1973);\\n    }\\n    else if (number == 1)\\n    {\\n      return new CD(\\\"Wigwam\\\", \\\"Nuclear Nightclub\\\", 1975);\\n    }\\n    else if (number == 2)\\n    {\\n      return new Book(\\\"Robert Martin\\\", \\\"Clean Code\\\", 1);\\n    }\\n    else if (number == 3)\\n    {\\n      return new Book(\\\"Kent Beck\\\", \\\"Test Driven Development\\\", 0.7);\\n    }\\n    else\\n    {\\n      return new ChocolateBar();\\n    }\\n  }\\n}\\n\")), mdx(\"p\", null, \"Rajapintojen k\\xE4ytt\\xF6 ohjelmoinnissa mahdollistaa luokkien v\\xE4lisen riippuvuuden v\\xE4hent\\xE4misen. Edellisess\\xE4 esimerkiss\\xE4 pakkaaja ei ole riippuvainen luokista jotka toteuttavat \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"IStorable\"), \"-rajapinnan. Sen sijaan se on riippuvainen rajapinnasta. T\\xE4m\\xE4 mahdollistaa uusien luokkien lis\\xE4\\xE4misen jotka toteuttavat \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"IStorable\"), \"-rajapinnan ilman ett\\xE4 pakkaajaa tarvitsee muuttaa. Lis\\xE4ksi uusien \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"IStorable\"), \"-rajapinnan toteuttavien luokkien lis\\xE4\\xE4minen ei vaikuta luokkiin jotka k\\xE4ytt\\xE4v\\xE4t pakkaajaa.\"), mdx(\"p\", null, \"Pakkaajamme voisi toimia vaikka n\\xE4in t\\xE4ll\\xE4 hetkell\\xE4:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"Packer packer = new Packer();\\n\\nforeach (IStorable item in packer.GiveAListOfThings())\\n{\\n  Console.WriteLine(item);\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"Kent Beck: Test Driven Development\\nPink Floyd - Dark Side of the Moon (1973)\\nPink Floyd - Dark Side of the Moon (1973)\\nWigwam - Nuclear Nightclub (1975)\\nPink Floyd - Dark Side of the Moon (1973)\\nWigwam - Nuclear Nightclub (1975)\\nCandybar, weight: 0.2\\nWigwam - Nuclear Nightclub (1975)\\nWigwam - Nuclear Nightclub (1975)\\nCandybar, weight: 0.2\\n\")), mdx(\"h2\", {\n    \"id\": \"rajapinnat-ja-ominaisuudet\"\n  }, \"Rajapinnat ja ominaisuudet\"), mdx(\"p\", null, \"T\\xE4h\\xE4n menness\\xE4 meill\\xE4 on ollut vain metodeja rajapinnoissa. Ent\\xE4 jos haluaisimme m\\xE4\\xE4ritell\\xE4 ominaisuuksia? Ne toimivat hyvin samalla tavalla kuin metodit, ja esimerkiksi \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"IStorable\"), \"-rajapintamme voisi olla paljon siistimpi ominaisuuden avulla, kuin metodin avulla. Katsotaanpa:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"public interface IStorable\\n{\\n  double weight { get; set; }\\n}\\n\")), mdx(\"p\", null, \"Kun nyt toteutamme luokkia jotka ovat IStorable, niill\\xE4 t\\xE4ytyy olla ominaisuus double weight, jolla on get ja set m\\xE4\\xE4riteltyn\\xE4. Nyt esimerkiksi Book n\\xE4ytt\\xE4isi t\\xE4lt\\xE4:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"public class Book : IStorable\\n{\\n  public string author;\\n  public string name;\\n  public double weight {get; set;}\\n  public Book(string author, string name, double weight)\\n  {\\n    this.author = author;\\n    this.name = name;\\n    this.weight = weight;\\n  }\\n\\n  public override string ToString()\\n  {\\n    return this.author + \\\": \\\" + this.name;\\n  }\\n}\\n\")), mdx(\"p\", null, \"Mist\\xE4 tiet\\xE4\\xE4, mit\\xE4 pit\\xE4\\xE4 milloinkin k\\xE4ytt\\xE4\\xE4? T\\xE4m\\xE4 tulee harjoituksen ja kokemuksen my\\xF6t\\xE4. Esimerkiksi kirjoissamme riitt\\xE4\\xE4 pelkk\\xE4 ominaisuus, mutta mit\\xE4 jos tarvitsisimme monimutkaisemman painoj\\xE4rjestelm\\xE4n? Esimerkiksi voisi olla kontti, johon mahtuu vain tietty paino. T\\xE4ll\\xF6in tarvitsisimme logiikkaa, ja metodi olisi perusteltu.\"), mdx(\"h2\", {\n    \"id\": \"geneeriset-rajapinnat-ja-lisää-lukemista\"\n  }, \"Geneeriset rajapinnat ja lis\\xE4\\xE4 lukemista\"), mdx(\"p\", null, \"Ohjelmointikielemme C# tarjoaa useita valmiita rajapintoja, joita voimme k\\xE4ytt\\xE4\\xE4, ja olemme jo k\\xE4ytt\\xE4neetkin. Voit lukea niist\\xE4 \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/generics/generic-interfaces\"\n  }, mdx(\"strong\", {\n    parentName: \"a\"\n  }, \"t\\xE4\\xE4lt\\xE4\")), \" tai \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic?view=net-6.0\"\n  }, mdx(\"strong\", {\n    parentName: \"a\"\n  }, \"t\\xE4\\xE4lt\\xE4\")), \". Molemmat linkit johtavat englanninkieliseen Microsoftin dokumentaatioon, ja antavat k\\xE4sityksen siit\\xE4, miten jotkin geneeriset rajapinnat on toteutettu.\"), mdx(\"h1\", {\n    \"id\": \"tehtävät\"\n  }, \"Teht\\xE4v\\xE4t\"), mdx(Exercise, {\n    title: '005 Taco Boxes',\n    mdxType: \"Exercise\"\n  }, mdx(\"p\", null, \"Teht\\xE4v\\xE4pohjasta l\\xF6yd\\xE4t rajapinnan \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"ITacoBox\"), \" valmiina k\\xE4ytett\\xE4v\\xE4ksi. Rajapinnassa on seuraavat metodit:\"), mdx(\"p\", null, \"Metodi \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"int TacosRemaining()\"), \" palauttaa j\\xE4ljell\\xE4 olevien tacojen m\\xE4\\xE4r\\xE4n.\\nMetodi \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"void Eat()\"), \" v\\xE4hent\\xE4\\xE4 j\\xE4ljell\\xE4 olevien tacojen m\\xE4\\xE4r\\xE4\\xE4 yhdell\\xE4. Tacojen m\\xE4\\xE4r\\xE4 ei voi menn\\xE4 negatiiviseksi.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Toteuta luokka \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"TripleTacoBox\"), \", joka toteuttaa rajapinnan \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"ITacoBox\"), \". Luokalla on konstruktori, joka ei ota parametreja. Luokalla on oliomuuttuja \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"tacos\"), \", joka alustetaan arvoon 3 konstruktorissa.\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Toteuta luokka \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"CustomTacoBox\"), \", joka toteuttaa rajapinnan \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"ITacoBox\"), \". Luokalla on konstruktori, joka ottaa parametrinaan tacojen m\\xE4\\xE4r\\xE4n. Luokalla on oliomuuttuja \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"tacos\"), \", joka alustetaan konstruktorissa parametrin arvolla.\"))), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"TripleTacoBox trip = new TripleTacoBox();\\nConsole.WriteLine(trip.TacosRemaining());\\ntrip.Eat();\\nConsole.WriteLine(trip.TacosRemaining());\\ntrip.Eat();\\nConsole.WriteLine(trip.TacosRemaining());\\ntrip.Eat();\\nConsole.WriteLine(trip.TacosRemaining());\\n// Koeta sy\\xF6d\\xE4 yksi liikaa\\ntrip.Eat();\\nConsole.WriteLine(trip.TacosRemaining());\\n\\nConsole.WriteLine();\\n\\nCustomTacoBox custom = new CustomTacoBox(2);\\nConsole.WriteLine(custom.TacosRemaining());\\ncustom.Eat();\\nConsole.WriteLine(custom.TacosRemaining());\\ncustom.Eat();\\nConsole.WriteLine(custom.TacosRemaining());\\n// Koeta sy\\xF6d\\xE4 yksi liikaa\\ncustom.Eat();\\nConsole.WriteLine(custom.TacosRemaining());\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"3\\n2\\n1\\n0\\n0\\n\\n2\\n1\\n0\\n0\\n\"))), mdx(Exercise, {\n    title: '006 Interface in a Box',\n    mdxType: \"Exercise\"\n  }, mdx(\"p\", null, \"Muuttaminen vaatii aina pakkaamista. Tehd\\xE4\\xE4n ohjelma, joka pakkaa tavaroita laatikoihin. Ohjelmassa on laatikkoja, ja tavaroita joita voidaan pakata laatikoihin. Kaikki laatikot ja tavarat toteuttavat rajapinnan \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"IPackable\"), \".\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"public interface IPackable {\\n    int Weight();\\n}\\n\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Osa 1\")), mdx(\"p\", null, \"Luo luokat \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Book\"), \" ja \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Furniture\"), \". Book-luokalla on konstruktori, joka saa parametreina kirjailijan (string), kirjan nimen (string) ja julkaisuvuoden (int). Kaikkien kirjojen paino on 1 kg. Furniture-luokalla on konstruktori, joka saa parametreina huonekalun tyypin (string), v\\xE4rin (string) ja painon (int). Molemmat luokat toteuttavat rajapinnan \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"IPackable\"), \". Luokilla on my\\xF6s \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"ToString\"), \"-metodi.\"), mdx(\"p\", null, \"Luokkien pit\\xE4isi toimia seuraavasti:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"Book book1 = new Book(\\\"Fedor Dostojevski\\\", \\\"Crime and Punishment\\\", 1866);\\nBook book2 = new Book(\\\"Robert Martin\\\", \\\"Clean Code\\\", 2008);\\nBook book3 = new Book(\\\"Kent Beck\\\", \\\"Test Driven Development\\\", 2000);\\n\\nFurniture sofa = new Furniture(\\\"Sofa\\\", \\\"Red\\\", 20);\\nFurniture bed = new Furniture(\\\"Twin bed\\\", \\\"White\\\", 15);\\nFurniture table = new Furniture(\\\"Dining room table\\\", \\\"Oak\\\", 30);\\n\\nList<IPackable> packages = new List<IPackable>();\\npackages.Add(book1);\\npackages.Add(book2);\\npackages.Add(book3);\\npackages.Add(sofa);\\npackages.Add(bed);\\npackages.Add(table);\\n\\npackages.ForEach(Console.WriteLine);\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"Fedor Dostojevski: Crime and Punishment (1866)\\nRobert Martin: Clean Code (2008)\\nKent Beck: Test Driven Development (2000)\\nRed Sofa - weight 20 kg\\nWhite Twin bed - weight 15 kg\\nOak Dining room table - weight 30 kg\\n\")), mdx(\"p\", null, \"Huomaa, ett\\xE4 kirjojen paino ei tulostu.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Osa 2\")), mdx(\"p\", null, \"Luo laatikolle luokka \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Box\"), \". Esineit\\xE4 jotka toteuttavat rajapinnan \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"IPackable\"), \" voidaan pakata laatikkoon. Laatikon konstruktori saa parametrina laatikon maksimikapasiteetin kilogrammoina. Kaikkien laatikossa olevien esineiden yhteispaino ei voi olla enemp\\xE4\\xE4 kuin laatikon maksimikapasiteetti. \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Boxin tulee my\\xF6s toteuttaa IPackable\"), \", joten laatikoihin voidaan pakata laatikoita!\"), mdx(\"p\", null, \"Alla on esimerkki laatikon k\\xE4yt\\xF6st\\xE4:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"Book book1 = new Book(\\\"Fedor Dostojevski\\\", \\\"Crime and Punishment\\\", 1866);\\nBook book2 = new Book(\\\"Robert Martin\\\", \\\"Clean Code\\\", 2008);\\nBook book3 = new Book(\\\"Kent Beck\\\", \\\"Test Driven Development\\\", 2000);\\n\\nFurniture sofa = new Furniture(\\\"Sofa\\\", \\\"Red\\\", 20);\\nFurniture bed = new Furniture(\\\"Twin bed\\\", \\\"White\\\", 15);\\nFurniture table = new Furniture(\\\"Dining room table\\\", \\\"Oak\\\", 30);\\n\\nBox box = new Box(40);\\nbox.Add(book1);\\nbox.Add(book2);\\nbox.Add(book3);\\nbox.Add(sofa);\\nbox.Add(bed);\\nbox.Add(table);\\n\\nConsole.WriteLine(box);\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"5 items, total weight 38 kg\\n\")), mdx(Note, {\n    mdxType: \"Note\"\n  }, \"P\\xF6yt\\xE4 ei mahtunut laatikkoon, koska laatikon maksimikapasiteetti on 40 kg.\"), mdx(\"p\", null, \"Kokeillaan my\\xF6s laatikoita laatikoiden sis\\xE4lle:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"Book book1 = new Book(\\\"Fedor Dostojevski\\\", \\\"Crime and Punishment\\\", 1866);\\nBook book2 = new Book(\\\"Robert Martin\\\", \\\"Clean Code\\\", 2008);\\nBook book3 = new Book(\\\"Kent Beck\\\", \\\"Test Driven Development\\\", 2000);\\n\\nFurniture sofa = new Furniture(\\\"Sofa\\\", \\\"Red\\\", 20);\\nFurniture bed = new Furniture(\\\"Twin bed\\\", \\\"White\\\", 15);\\nFurniture table = new Furniture(\\\"Dining room table\\\", \\\"Oak\\\", 30);\\n\\nBox bookBox = new Box(5);\\nbookBox.Add(book1);\\nbookBox.Add(book2);\\nbookBox.Add(book3);\\n\\nConsole.WriteLine(bookBox);\\nConsole.WriteLine();\\n\\nBox movingVan = new Box(800);\\nmovingVan.Add(bookBox);\\nmovingVan.Add(sofa);\\nmovingVan.Add(bed);\\nmovingVan.Add(table);\\n\\nConsole.WriteLine(movingVan);\\nConsole.WriteLine();\\n\\nBox shippingContainer = new Box(3000);\\nshippingContainer.Add(movingVan);\\n\\nConsole.WriteLine(shippingContainer);\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"3 items, total weight 3 kg\\n\\n4 items, total weight 68 kg\\n\\n1 items, total weight 68 kg\\n\"))), mdx(Exercise, {\n    title: '007 Herds',\n    mdxType: \"Exercise\"\n  }, mdx(\"p\", null, \"T\\xE4ss\\xE4 teht\\xE4v\\xE4ss\\xE4 luomme organismin ja lauman organismeja, jotka voivat liikkua. Organismien sijaintien esitt\\xE4miseen k\\xE4yt\\xE4mme kaksiulotteista koordinaatistoa. Jokainen sijainti koostuu kahdesta luvusta: x- ja y-koordinaateista. X-koordinaatti kertoo kuinka kaukana sijainti on origosta (eli pisteest\\xE4, jossa x = 0 ja y = 0) vaakasuunnassa. Y-koordinaatti kertoo kuinka kaukana sijainti on origosta pystysuunnassa. Jos et ole tutustunut koordinaatistoon, voit lukea siit\\xE4 esimerkiksi \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://fi.wikipedia.org/wiki/Koordinaatisto\"\n  }, mdx(\"strong\", {\n    parentName: \"a\"\n  }, \"Wikipediasta\")), \".\"), mdx(\"p\", null, \"Teht\\xE4v\\xE4pohjassa on valmiina rajapinta \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"IMovable\"), \", joka kuvaa liikuteltavaa asiaa. Rajapinta sis\\xE4lt\\xE4\\xE4 metodin \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"void Move(int dx, int dy)\"), \". Parametri dx kertoo kuinka paljon asia liikkuu x-akselilla, ja parametri dy kertoo kuinka paljon asia liikkuu y-akselilla.\"), mdx(\"p\", null, \"Teht\\xE4v\\xE4 koostuu luokkien \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Organism\"), \" ja \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Herd\"), \" toteuttamisesta. Molemmat luokat toteuttavat rajapinnan \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"IMovable\"), \". \"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Osa 1\")), mdx(\"p\", null, \"Luo luokka \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Organism\"), \", joka toteuttaa rajapinnan \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"IMovable\"), \". Organismi tiet\\xE4\\xE4 oman sijaintinsa (x- ja y-koordinaatit). Organismin API on seuraava:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"public Organism(int x, int y)\")), mdx(\"p\", null, \"Luokan konstruktori, joka saa parametreina organismin alkusijainnin x- ja y-koordinaatit.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"public override string ToString()\")), mdx(\"p\", null, \"Luo ja palauttaa organismin merkkijonoesityksen. Merkkijonoesityksen tulee olla seuraavanlainen: \\\"x: 3; y: 6\\\". Huomaa, ett\\xE4 koordinaattien v\\xE4liss\\xE4 on puolipiste.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"public void Move(int dx, int dy)\")), mdx(\"p\", null, \"Liikuttaa organismin sijaintia parametrien dx ja dy osoittamalla tavalla. Jos dx on 5, organismin x-koordinaatin arvo kasvaa viidell\\xE4. Jos dx on -3, organismin x-koordinaatin arvo pienenee kolmella. Sama p\\xE4tee parametrin dy kohdalla.\"), mdx(\"p\", null, \"K\\xE4yt\\xE4 seuraavaa koodia organismin testaamiseen:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"Organism organism = new Organism(20, 30);\\nConsole.WriteLine(organism);\\norganism.Move(-10, 5);\\nConsole.WriteLine(organism);\\norganism.Move(50, 20);\\nConsole.WriteLine(organism);\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"x: 20; y: 30 \\nx: 10; y: 35 \\nx: 60; y: 55\\n\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Osa 2\")), mdx(\"p\", null, \"Luo luokka \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Herd\"), \", joka toteuttaa rajapinnan \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"IMovable\"), \". Lauma koostuu useista \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"IMovable\"), \"-rajapinnan toteuttavista olioista. Ne tulee tallentaa esimerkiksi listarakenteeseen.\"), mdx(\"p\", null, \"Luokan \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Herd\"), \" API on seuraava:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"public override string ToString()\")), mdx(\"p\", null, \"Palauttaa lauman j\\xE4senten sijainnit merkkijonona. Jokaisen j\\xE4senen sijainti tulee olla omalla rivill\\xE4\\xE4n. \"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"public void AddToHerd(IMovable movable)\")), mdx(\"p\", null, \"Lis\\xE4\\xE4 \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"IMovable\"), \"-rajapinnan toteuttavan olion laumaan.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"public void Move(int dx, int dy)\")), mdx(\"p\", null, \"Liikuttaa lauman j\\xE4seni\\xE4 parametrien dx ja dy osoittamalla tavalla. Jos dx on 5, kaikkien lauman j\\xE4senten x-koordinaatin arvo kasvaa viidell\\xE4. Jos dx on -3, kaikkien lauman j\\xE4senten x-koordinaatin arvo pienenee kolmella. Sama p\\xE4tee parametrin dy kohdalla.\"), mdx(\"p\", null, \"Kokeile ohjelmaa seuraavalla koodilla:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"Herd herd = new Herd();\\nherd.AddToHerd(new Organism(57, 66));\\nherd.AddToHerd(new Organism(73, 56));\\nherd.AddToHerd(new Organism(46, 52));\\nherd.AddToHerd(new Organism(19, 107));\\nConsole.WriteLine(herd);\\nherd.Move(2,2);\\nConsole.WriteLine(herd);\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"x: 57; y: 66 \\nx: 73; y: 56 \\nx: 46; y: 52 \\nx: 19; y: 107\\n\\nx: 59; y: 68 \\nx: 75; y: 58 \\nx: 48; y: 54 \\nx: 21; y: 109\\n\\n\")), mdx(Note, {\n    mdxType: \"Note\"\n  }, \"Lauman ToString saattaa p\\xE4\\xE4tty\\xE4 rivinvaihtoon, ja se on ihan ok!\")));\n}\n;\nMDXContent.isMDXComponent = true;","tableOfContents":{"items":[{"items":[{"url":"#rajapinnat-muuttujatyyppeinä","title":"Rajapinnat muuttujatyyppeinä"},{"url":"#rajapinnat-metodin-parametreina","title":"Rajapinnat metodin parametreina"},{"url":"#rajapinta-metodin-paluuarvona","title":"Rajapinta metodin paluuarvona"},{"url":"#rajapinnat-ja-ominaisuudet","title":"Rajapinnat ja ominaisuudet"},{"url":"#geneeriset-rajapinnat-ja-lisää-lukemista","title":"Geneeriset rajapinnat ja lisää lukemista"}]},{"url":"#tehtävät","title":"Tehtävät"}]},"frontmatter":{"title":"Rajapinnat"}}},"pageContext":{"id":"4d4c64c1-8684-59b4-ab85-2084d9f2d7df"}},
    "staticQueryHashes": ["1885717130","1950529541","2744905544","3020054368"]}