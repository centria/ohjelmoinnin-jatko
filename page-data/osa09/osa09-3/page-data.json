{
    "componentChunkName": "component---src-templates-docs-js",
    "path": "/osa09/osa09-3",
    "result": {"data":{"mdx":{"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Polymorfismi\",\n  \"nav_order\": 93,\n  \"hidden\": false\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar Exercise = makeShortcode(\"Exercise\");\nvar Note = makeShortcode(\"Note\");\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Olemme t\\xF6rm\\xE4nneet tilanteisiin, miss\\xE4 viittaustyyppisill\\xE4 muuttujilla on muitakin tyyppej\\xE4 kuin oma tyypins\\xE4. Esimerkiksi kaikki oliot ovat tyypilt\\xE4\\xE4n Object, eli mink\\xE4 tahansa olion voi esitt\\xE4\\xE4 my\\xF6s Object-tyyppisen\\xE4 muuttujana.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"string text = \\\"text\\\";\\nObject textString = \\\"another string\\\";\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"string text = \\\"text\\\";\\nObject textString = text;\\n\")), mdx(\"p\", null, \"Yll\\xE4 olevassa esimerkiss\\xE4, merkkijonomuuttuja esitet\\xE4\\xE4n sek\\xE4 String-tyyppisen\\xE4 ett\\xE4 Object-tyyppisen\\xE4. Lis\\xE4ksi String-tyyppinen muuttuja sijoitetaan Object-tyyppiseen muuttujaan. Toiseen suuntaan sijoittaminen, eli Object-tyyppisen muuttujan asettaminen String-tyyppiseksi, ei kuitenkaan onnistu. T\\xE4m\\xE4 johtuu siit\\xE4, ett\\xE4 Object-tyyppiset muuttujat eiv\\xE4t ole String-tyyppisi\\xE4.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"Object textString = \\\"another string\\\";\\nstring text = textString; // EI TOIMI!\\n\")), mdx(\"p\", null, \"Mist\\xE4 t\\xE4ss\\xE4 oikein on kyse?\"), mdx(\"p\", null, \"Oman alkuper\\xE4isen tyyppins\\xE4 lis\\xE4ksi, jokainen muuttuja voi olla my\\xF6s niiden rajapintojen ja luokkien tyyppi\\xE4, joita se toteuttaa ja perii. String-luokka perii Object-luokan ja on siten aina my\\xF6s Object-tyyppinen. Object-luokka ei periydy String-luokasta, joten Object-tyyppiset muuttujat eiv\\xE4t ole automaattisesti String-tyyppisi\\xE4. Jos tarkastelemme String-luokan \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://docs.microsoft.com/en-us/dotnet/api/system.string?view=net-6.0\"\n  }, mdx(\"strong\", {\n    parentName: \"a\"\n  }, \"API-dokumentaatiota\")), \", n\\xE4emme ett\\xE4 se perii Object-luokan:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"Object --> String\\n\")), mdx(\"p\", null, \"Perint\\xE4hierarkia listaa kaikki ne luokat, joista annettu luokka on perinyt. Perityt luokat listataan perint\\xE4j\\xE4rjestyksess\\xE4, jolloin tarkasteltava luokka on aina alimpana. String-luokan perint\\xE4hierarkiasta n\\xE4emme, ett\\xE4 String-luokka perii Object-luokan. C#-kielell\\xE4 \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"jokainen luokka voi suoraan peri\\xE4 korkeintaan yhden luokan\"), \". Toisaalta, peritty luokka voi olla perinyt toisen luokan. T\\xE4ll\\xF6in luokka voi periaatteessa peri\\xE4 ep\\xE4suorasti useampia kuin yhden luokan.\"), mdx(\"p\", null, \"Perint\\xE4hierarkia voidaan ajatella my\\xF6s listana niist\\xE4 eri tyypeist\\xE4, joita luokka toteuttaa.\"), mdx(\"p\", null, \"Tieto siit\\xE4, ett\\xE4 oliot voivat olla monenlaisia, esimerkiksi Object-tyyppisi\\xE4, tekee ohjelmoinnista helpompaa. Jos tarvitsemme metodissa vain Object-luokassa m\\xE4\\xE4riteltyj\\xE4 metodeja, kuten \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"ToString\"), \", \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Equals\"), \" ja \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"GetHashCode\"), \", voimme k\\xE4ytt\\xE4\\xE4 metodin parametrin tyypiksi suoraan Objectia. T\\xE4ll\\xF6in metodille voidaan antaa parametrina mik\\xE4 tahansa olio. Katsotaan t\\xE4t\\xE4 \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"PrintManyTimes\"), \"-metodin avulla. Metodi saa parametreinaan Object-tyyppisen muuttujan ja tulostusten m\\xE4\\xE4r\\xE4n.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"public void PrintManyTimes(Object obj, int times)\\n{\\n  int i = 0;\\n  while (i < times)\\n  {\\n    Console.WriteLine(obj.ToString());\\n\\n    i = i + 1;\\n  }\\n}\\n\")), mdx(\"p\", null, \"Metodille voidaan antaa parametrina mit\\xE4 tahansa oliota. Metodin PrintManyTimes sis\\xE4ll\\xE4 oliolla on p\\xE4\\xE4sy vain Object-luokassa m\\xE4\\xE4riteltyihin metodeihin, koska metodi tuntee olion olevan tyyppi\\xE4 Object. Olio voi kuitenkin olla my\\xF6s jotain muuta tyyppi\\xE4.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"Printer printer = new Printer();\\n\\nstring str = \\\" o \\\";\\nList<string> words = new List<string>();\\nwords.Add(\\\"polymorphism\\\");\\nwords.Add(\\\"inheritance\\\");\\nwords.Add(\\\"encapsulation\\\");\\nwords.Add(\\\"abstraction\\\");\\n\\nprinter.PrintManyTimes(str, 2);\\nprinter.PrintManyTimes(words, 3);\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \" o \\n o\\nSystem.Collections.Generic.List`1[System.String]\\nSystem.Collections.Generic.List`1[System.String]\\nSystem.Collections.Generic.List`1[System.String]\\n\")), mdx(\"p\", null, \"Jatketaan String-luokan API-dokumentaation tarkastelua. Perint\\xE4hierarkian j\\xE4lkeen dokumentaatiossa on lista luokan toteuttamista rajapinnoista. \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"[System.Runtime.InteropServices.ComVisible(true)]\\n[System.Serializable]\\npublic sealed class String : ICloneable, IComparable, IComparable<string>, IConvertible, IEquatable<string>, System.Collections.Generic.IEnumerable<char>\\n\")), mdx(\"p\", null, \"String-luokka toteuttaa useita rajapintoja, kuten \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"IComparable\"), \", \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"IConvertible\"), \" ja \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"ICloneable\"), \".\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"ICloneable cloneableString = \\\"string\\\";\\nIComparable comparableString = \\\"string\\\";\\nIConvertible convertibleString = \\\"string\\\";\\n\")), mdx(\"p\", null, \"Koska voimme m\\xE4\\xE4ritell\\xE4 metodin parametrien tyypin, voimme m\\xE4\\xE4ritell\\xE4 metodeita jotka ottavat parametrina olioita jotka toteuttavat tietyn rajapinnan. Kun metorin parametrina on siis annettu parametri, mik\\xE4 tahansa olio joka toteuttaa rajapintaa, voidaan antaa argumenttina.\"), mdx(\"h2\", {\n    \"id\": \"usean-abstraktin-luokan-ja-rajapinnan-toteuttaminen\"\n  }, \"Usean abstraktin luokan ja rajapinnan toteuttaminen\"), mdx(\"p\", null, \"Kuten aiemmin todettu, luokka voi peri\\xE4 korkeintaan yhden luokan suoraan, mutta voi peri\\xE4 my\\xF6s rajapinnan, tai itseasiassa useita rajapintoja, luokan lis\\xE4ksi. Milt\\xE4 t\\xE4m\\xE4 n\\xE4ytt\\xE4\\xE4 koodissa?\"), mdx(\"p\", null, \"Vastaus on yksinkertainen, listataan ne pilkulla erotettuna. Esimerkiksi luokka teht\\xE4vist\\xE4mme:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"public class Cat : Animal, INoiseCapable\\n{\\n  // Kaikki koodi mit\\xE4 luokassa on\\n}\\n\")), mdx(\"p\", null, \"Nyt meill\\xE4 on luokka \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Cat\"), \", joka perii abstraktin luokan \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Animal\"), \" ja toteuttaa rajapinnan \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"INoiseCapable\"), \".\"), mdx(\"p\", null, \"Nyt my\\xF6s huomataan, miksi iso \\\"I\\\" on hyv\\xE4 k\\xE4yt\\xE4nt\\xF6 rajapintojen nimiss\\xE4: Sen avulla voimme suoraan erottaa rajapinnat luokista, ja tied\\xE4mme koodia lukematta, kumpi on kumpi.\"), mdx(\"h1\", {\n    \"id\": \"tehtävät\"\n  }, \"Teht\\xE4v\\xE4t\"), mdx(Exercise, {\n    title: '008 Animals',\n    mdxType: \"Exercise\"\n  }, mdx(\"p\", null, \"T\\xE4ss\\xE4 teht\\xE4v\\xE4ss\\xE4 harjoitellaan perint\\xE4\\xE4 ja rajapintoja yht\\xE4aikaa.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Ensin luodaan abstrakti luokka \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Animal\"), \". Luokalla on konstruktori, joka ottaa el\\xE4imen nimen parametrina. Animal-luokalla on my\\xF6s parametrittomat metodit \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Eat\"), \" ja \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Sleep\"), \", jotka eiv\\xE4t palauta mit\\xE4\\xE4n (void).\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Metodi Sleep tulostaa \\\"(name) sleeps\\\", ja metodi Eat tulostaa \\\"(name) eats\\\". T\\xE4ss\\xE4 (name) on kyseisen el\\xE4imen nimi.\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Toteuta luokka \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Dog\"), \" joka perii Animal-luokan. Luokalla on kaksi konstruktoria: toinen parametriton, joka asettaa koiran nimeksi \\\"Dog\\\", ja toinen parametrillinen, joka asettaa koiran nimeksi parametrina annetun nimen. Luokalla on my\\xF6s parametriton metodi \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Bark\"), \", joka ei palauta mit\\xE4\\xE4n (void). Metodi tulostaa \\\"(name) barks\\\", miss\\xE4 (name) on koiran nimi. Kuten kaikilla el\\xE4imill\\xE4, koiralla on my\\xF6s metodit Eat ja Sleep.\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Toteuta luokka \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Cat\"), \", joka perii Animal-luokan. Luokalla on kaksi konstruktoria: toinen parametriton, joka asettaa kissan nimeksi \\\"Cat\\\", ja toinen parametrillinen, joka asettaa kissan nimeksi parametrina annetun nimen. Luokalla on my\\xF6s parametriton metodi \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Purr\"), \", joka ei palauta mit\\xE4\\xE4n (void). Metodi tulostaa \\\"(name) purrs\\\", miss\\xE4 (name) on kissan nimi. Kuten kaikilla el\\xE4imill\\xE4, kissalla on my\\xF6s metodit Eat ja Sleep.\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Lopulta luodaan rajapinta \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"INoiseCapable\"), \". Rajapinnalla on metodi \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"MakeNoise\"), \", joka ei palauta mit\\xE4\\xE4n (void). Rajapinta ottaa k\\xE4ytt\\xF6\\xF6ns\\xE4 metodit Bark ja Purr, jotka on toteutettu Dog- ja Cat-luokissa.\"))), mdx(\"p\", null, \"Alla on esimerkki kaikkien luokkien toiminnasta.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"Dog dog = new Dog();\\ndog.Bark();\\ndog.Eat();\\ndog.Sleep();\\n\\nDog fido = new Dog(\\\"Fido\\\");\\nfido.Bark();\\n\\nCat cat = new Cat();\\ncat.Purr();\\ncat.Eat();\\ncat.Sleep();\\n\\nCat garfield = new Cat(\\\"Garfield\\\");\\ngarfield.Purr();\\n\\nINoiseCapable doggy = new Dog();\\ndoggy.MakeNoise();\\n\\nINoiseCapable catty = new Cat(\\\"Garfield\\\");\\ncatty.MakeNoise();\\n\\nCat c = (Cat) catty;\\nc.Purr();\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"Dog barks\\nDog eats\\nDog sleeps\\nFido barks\\nCat purrs\\nCat eats \\nCat sleeps\\nGarfield purrs\\nDog barks \\nGarfield purrs \\nGarfield purrs\\n\")), mdx(Note, {\n    mdxType: \"Note\"\n  }, \"T\\xE4m\\xE4 teht\\xE4v\\xE4 on arvoltaan 2 pistett\\xE4, ja vaatii kaikkien toteutettujen luokkien toimivan pisteit\\xE4 varten.\")));\n}\n;\nMDXContent.isMDXComponent = true;","tableOfContents":{"items":[{"items":[{"url":"#usean-abstraktin-luokan-ja-rajapinnan-toteuttaminen","title":"Usean abstraktin luokan ja rajapinnan toteuttaminen"}]},{"url":"#tehtävät","title":"Tehtävät"}]},"frontmatter":{"title":"Polymorfismi"}}},"pageContext":{"id":"ccf15ac3-7d3f-52a0-a04b-de3268933942"}},
    "staticQueryHashes": ["1885717130","1950529541","2744905544","3020054368"]}