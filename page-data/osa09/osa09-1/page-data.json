{
    "componentChunkName": "component---src-templates-docs-js",
    "path": "/osa09/osa09-1",
    "result": {"data":{"mdx":{"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Perintä\",\n  \"nav_order\": 91,\n  \"hidden\": false\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar Note = makeShortcode(\"Note\");\nvar Exercise = makeShortcode(\"Exercise\");\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Luokkia k\\xE4ytet\\xE4\\xE4n selkeytt\\xE4m\\xE4\\xE4n olio-ohjelmoinnin ongelmakent\\xE4n konsepteja. Jokainen ljomalle luokka lis\\xE4\\xE4 ohjelmointikieleen uutta toiminnallisuutta. T\\xE4m\\xE4 toiminnallisuus on tarpeen, jotta voimme ratkaista kohtaamiamme ongelmia. Olennaista oliopohjaisessa ohjelmoinnissa on, ett\\xE4 \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"ratkaisut syntyv\\xE4t olioiden v\\xE4lisest\\xE4 vuorovaikutuksesta, jotka luodaan luokista\"), \". Olio-ohjelmoinnissa olio on itsen\\xE4inen yksikk\\xF6, jolla on tila, jota voidaan muuttaa k\\xE4ytt\\xE4m\\xE4ll\\xE4 oliolle tarjottuja metodeja. Oliot toimivat yhteisty\\xF6ss\\xE4, ja jokaisella on oma vastuualueensa.\"), mdx(\"p\", null, \"Jokainen luokka C#:ssa laajentaa luokkaa \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Object\"), \", mik\\xE4 tarkoittaa, ett\\xE4 jokaisella luokalla on k\\xE4yt\\xF6ss\\xE4\\xE4n kaikki \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Object\"), \"-luokassa m\\xE4\\xE4ritellyt metodit. Jos haluamme muuttaa, miten \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Object\"), \"-luokassa m\\xE4\\xE4ritellyt metodit toimivat, ne t\\xE4ytyy ylikirjoittaa m\\xE4\\xE4rittelem\\xE4ll\\xE4 uusi toteutus niille luokassa, jota olemme luomassa. Luomamme oliot saavat metodit \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Equals\"), \" ja \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"GetHashCode\"), \" muiden joukossa \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Object\"), \"-luokasta.\"), mdx(\"p\", null, \"Jokainen luokkaa perii luokan \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Object\"), \", mutta on mahdollista peri\\xE4 my\\xF6s muita luokkia. Jos tutkimme C#:n \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://learn.microsoft.com/en-us/dotnet/api/system.int32?view=net-6.0\"\n  }, mdx(\"strong\", {\n    parentName: \"a\"\n  }, \"Int32\")), \" (eli kokonaisluku) -luokan API:a (eli Application Programming Interface, ohjelmointirajapinta), huomaamme, ett\\xE4 \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Int32\"), \":lla on \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"ValueType\"), \"-niminen \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"yliluokka\"), \". \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"ValueType\"), \":lla on puolestaan \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Object\"), \"-luokka yliluokkanaan.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"Inheritance\\nObject --> ValueType --> Int32\\n\")), mdx(\"p\", null, \"Jokainen luokka voi suoraan laajentaa vain yht\\xE4 luokkaa. V\\xE4lillisesti luokka kuitenkin perii kaiken mit\\xE4 peritty luokka laajentaa. T\\xE4ten esimerkin \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Int32\"), \"-luokalla on k\\xE4yt\\xF6ss\\xE4\\xE4n \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"ValueType\"), \"- ja \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Object\"), \"-luokkien muuttujat ja metodit.\"), mdx(\"p\", null, \"K\\xE4yt\\xE4mme \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \":\"), \" (eli kaksoispistett\\xE4) merkitsem\\xE4\\xE4n luokan perint\\xE4\\xE4. Luokka, joka saa perityt ominaisuudet, on \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"johdettu luokka\"), \" ja luokka, jonka ominaisuudet perit\\xE4\\xE4n, on \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"yliluokka\"), \".\"), mdx(\"p\", null, \"Tarkastellaan luokkaa autojen valmistusj\\xE4rjestelm\\xE4ss\\xE4, joka hallinnoi auton osia. Osien hallinnan peruskomponentti on luokka \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Part\"), \", joka m\\xE4\\xE4rittelee tunnisteen, valmistajan ja kuvauksen.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"namespace Exercise001\\n{\\n  public class Part\\n  {\\n\\n    public string identifier { get; }\\n    public string manufacturer { get; }\\n    public string description { get; }\\n\\n    public Part(string identifier, string manufacturer, string description)\\n    {\\n      this.identifier = identifier;\\n      this.manufacturer = manufacturer;\\n      this.description = description;\\n    }\\n  }\\n}\\n\")), mdx(\"p\", null, \"Yksi auton osa on moottori. Kuten kaikki osat, my\\xF6s moottorilla on valmistaja, tunniste ja kuvaus. Lis\\xE4ksi jokaisella moottorilla on tyyppi, kuten polttomoottori, s\\xE4hk\\xF6moottori tai hybridimoottori.\"), mdx(\"p\", null, \"Perinteinen tapa toteuttaa luokka \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Engine\"), \" ilman perint\\xE4\\xE4 olisi seuraava.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"namespace Exercise001\\n{\\n  public class Engine\\n  {\\n    public string engineType { get; }\\n    public string identifier { get; }\\n    public string manufacturer { get; }\\n    public string description { get; }\\n\\n    public Engine(string engineType, string identifier, string manufacturer, string description)\\n    {\\n      this.engineType = engineType;\\n      this.identifier = identifier;\\n      this.manufacturer = manufacturer;\\n      this.description = description;\\n    }\\n  }\\n}\\n\")), mdx(\"p\", null, \"Huomaamme merkitt\\xE4v\\xE4n m\\xE4\\xE4r\\xE4n p\\xE4\\xE4llekk\\xE4isyytt\\xE4 \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Engine\"), \"- ja \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Part\"), \"-luokkien v\\xE4lill\\xE4. Voimme sanoa, ett\\xE4 \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Engine\"), \" on erikoistapaus \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Part\"), \"-luokasta. Moottori on osa, mutta sill\\xE4 on my\\xF6s ominaisuuksia, joita osalla ei ole, kuten moottorin tyyppi.\"), mdx(\"p\", null, \"Luodaan uudelleen \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Engine\"), \"-luokka ja k\\xE4ytet\\xE4\\xE4n t\\xE4ll\\xE4 kertaa perint\\xE4\\xE4 toteutuksessa. Luomme luokan \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Engine\"), \", joka perii luokan \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Part\"), \": moottori on erikoistapaus osasta.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"namespace Exercise001\\n{\\n  public class Engine : Part\\n  {\\n    public string engineType { get; }\\n\\n    public Engine(string engineType, string identifier, string manufacturer, string description) : \\n      base(identifier, manufacturer, description)\\n    {\\n      this.engineType = engineType;\\n    }\\n  }\\n}\\n\")), mdx(\"p\", null, \"Luokan m\\xE4\\xE4rittely \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"public class Engine : Part\"), \" tarkoittaa, ett\\xE4 luokka \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Engine\"), \" perii luokan \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Part\"), \" ominaisuudet. M\\xE4\\xE4rittelemme my\\xF6s luokassa \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Engine\"), \" muuttujan \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"engineType\"), \".\"), mdx(\"p\", null, \"Luokan \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Engine\"), \" konstruktori on mielenkiintoinen. Sen m\\xE4\\xE4rittelyrivill\\xE4 k\\xE4yt\\xE4mme avainsanaa \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"base\"), \" kutsuaksemme yliluokan konstruktoria. Kutsu \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"base(identifier, manufacturer, description)\"), \" kutsuu konstruktoria \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"public Part(string identifier, string manufacturer, string description)\"), \", joka on m\\xE4\\xE4ritelty luokassa \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Part\"), \". T\\xE4m\\xE4n kautta yliluokan muuttujat alustetaan niiden alkuper\\xE4isill\\xE4 arvoilla. \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"base\"), \"-kutsun j\\xE4lkeen \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Engine\"), \"-konstruktorin koodilohkossa asetamme muuttujalle \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"engineType\"), \" oikean arvon.\"), mdx(Note, {\n    mdxType: \"Note\"\n  }, \"Yliluokan base -kutsu muistuttaa hieman konstruktorin this -kutsua (eli kun ylikirjoitetaan konstruktoria); t\\xE4ll\\xE4 kutsutaan t\\xE4m\\xE4n luokan konstruktoria, kun taas base -kutsulla kutsutaan yliluokan konstruktoria. Jos konstruktori k\\xE4ytt\\xE4\\xE4 yliluokan konstruktoria, eli base -kutsua, t\\xE4ytyy base -kutsu olla konstruktorin m\\xE4\\xE4rittelyrivill\\xE4. T\\xE4m\\xE4 on samankaltainen tilanne kuin this -kutsun kanssa (t\\xE4ytyy my\\xF6s olla konstruktorin m\\xE4\\xE4rittelyrivill\\xE4).\"), mdx(\"p\", null, \"Koska luokka Engline laajentaa luokkaa Part, sill\\xE4 on k\\xE4yt\\xF6ss\\xE4\\xE4n kaikki luokan Part tarjoamat metodit. Voimme luoda luokan Engine instansseja samalla tavalla kuin mit\\xE4 tahansa muita luokkia.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"static void Main(string[] args)\\n{\\n  Engine engine = new Engine(\\\"combustion\\\", \\\"hz\\\", \\\"volkswagen\\\", \\\"VW GOLF 1L 86-91\\\");\\n  Console.WriteLine(engine.engineType);\\n  Console.WriteLine(engine.identifier);\\n  Console.WriteLine(engine.manufacturer);\\n  Console.WriteLine(engine.description);\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"combustion\\nhz\\nvolkswagen\\nVW GOLF 1L 86-91\\n\")), mdx(\"p\", null, \"Kuten n\\xE4emme, luokka \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Engine\"), \" sis\\xE4lt\\xE4\\xE4 kaikki \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Part\"), \"-luokan muuttujat. \"), mdx(\"h2\", {\n    \"id\": \"suojausmääreet-private-protected-ja-public\"\n  }, \"Suojausm\\xE4\\xE4reet private, protected ja public\"), mdx(\"p\", null, \"Yksityiset muuttujat ovat n\\xE4kyviss\\xE4 vain johdetuissa luokissa, jotka ovat sis\\xE4kk\\xE4isi\\xE4 yliluokkansa kanssa. Muuten ne eiv\\xE4t ole n\\xE4kyviss\\xE4 johdetuissa luokissa. Joten \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Engine\"), \"-luokasta ei olisi mit\\xE4\\xE4n tapaa suoraan k\\xE4ytt\\xE4\\xE4 muuttujia \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"identifier\"), \", \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"manufacturer\"), \" ja \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"description\"), \", jos ne olisivat m\\xE4\\xE4ritelty yksityisiksi \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Part\"), \"-luokassa. Nyt ne ovat julkisia, ja siten k\\xE4ytett\\xE4viss\\xE4 johdetuissa luokissa.\"), mdx(Note, {\n    mdxType: \"Note\"\n  }, \"Emme ole m\\xE4\\xE4ritt\\xE4neet set avainsanaa luokassa Part. T\\xE4m\\xE4 tarkoittaa, ett\\xE4 johdetut luokat eiv\\xE4t voi asettaa muuttujien arvoja Part-luokassa.\"), mdx(\"p\", null, \"Johdettu luokka n\\xE4kee kaiken, mik\\xE4 on m\\xE4\\xE4ritelty \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"public\"), \"-m\\xE4\\xE4ritteell\\xE4 yliluokassa. Jos haluamme m\\xE4\\xE4ritell\\xE4 muuttujia tai metodeja, jotka ovat n\\xE4kyviss\\xE4 johdetuissa luokissa, mutta eiv\\xE4t muualla, voimme k\\xE4ytt\\xE4\\xE4 \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"protected\"), \"-m\\xE4\\xE4rett\\xE4.\"), mdx(\"h2\", {\n    \"id\": \"konstruktorin-kutsuminen-yliluokasta\"\n  }, \"Konstruktorin kutsuminen yliluokasta\"), mdx(\"p\", null, \"Olemme k\\xE4ytt\\xE4neet avainsanaa \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"base\"), \" kutsuaksemme yliluokan konstruktoria. Kutsu saa parametreikseen yliluokan konstruktorin vaatimat arvot. Jos yliluokassa on useita konstruktoreita, parametrien m\\xE4\\xE4r\\xE4 m\\xE4\\xE4ritt\\xE4\\xE4, mit\\xE4 konstruktoria kutsutaan.\"), mdx(\"p\", null, \"Kun (johdetun luokan) konstruktoria kutsutaan, yliluokassa m\\xE4\\xE4ritetyt muuttujat alustetaan. Tapahtumat, jotka tapahtuvat konstruktorin kutsun aikana, ovat k\\xE4yt\\xE4nn\\xF6ss\\xE4 identtisi\\xE4 normaalin konstruktorikutsun kanssa. Jos yliluokka ei tarjoa parametritonta konstruktoria, johdetun luokan konstruktorissa t\\xE4ytyy aina olla selke\\xE4 kutsu yliluokan konstruktorille.\"), mdx(\"p\", null, \"Demonstroimme t\\xE4t\\xE4 seuraavassa esimerkiss\\xE4, kuinka kutsutaan \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"this\"), \" ja \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"base\"), \". Luokka \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Baseclass\"), \" sis\\xE4lt\\xE4\\xE4 oliomuuttujan ja kaksi konstruktoria. Toinen niist\\xE4 kutsuu toista konstruktoria \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"this\"), \"-avainsanalla. Luokka \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"DerivedClass\"), \" sis\\xE4lt\\xE4\\xE4 parametrillisen konstruktorin, mutta sill\\xE4 ei ole oliomuuttujia. Johdetun luokan konstruktori kutsuu yliluokan parametrillist\\xE4 konstruktoria.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"namespace Exercise001\\n{\\n  public class BaseClass\\n  {\\n    private string objectVariable;\\n\\n    public BaseClass() : this(\\\"Example\\\")\\n    {\\n    }\\n\\n    public BaseClass(string value)\\n    {\\n      this.objectVariable = value;\\n    }\\n\\n    public override string ToString()\\n    {\\n      return this.objectVariable;\\n    }\\n  }\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"namespace Exercise001\\n{\\n  public class DerivedClass : BaseClass\\n  {\\n    public DerivedClass() : base(\\\"Derived Class\\\")\\n    {\\n    }\\n  }\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"BaseClass bas = new BaseClass();\\nDerivedClass der = new DerivedClass();\\n\\nConsole.WriteLine(bas);\\nConsole.WriteLine(der);\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"Example\\nDerived Class\\n\")), mdx(\"h2\", {\n    \"id\": \"yliluokan-metodin-kutsuminen\"\n  }, \"Yliluokan metodin kutsuminen\"), mdx(\"p\", null, \"Voit kutsua yliluokan m\\xE4\\xE4rittelemi\\xE4 metodeja k\\xE4ytt\\xE4m\\xE4ll\\xE4 avainsanaa \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"base\"), \", aivan kuten voit kutsua johdetun luokan m\\xE4\\xE4rittelemi\\xE4 metodeja k\\xE4ytt\\xE4m\\xE4ll\\xE4 avainsanaa \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"this\"), \". Esimerkiksi ylikirjoittaessasi \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"ToString\"), \"-metodia voit kutsua yliluokan m\\xE4\\xE4rittelem\\xE4\\xE4 metodia seuraavasti:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"public override string ToString()\\n{\\n  return \\\"override: \\\" + base.ToString();\\n}\\n\")), mdx(\"p\", null, \"T\\xE4ll\\xF6in edellisen esimerkin tulostus n\\xE4ytt\\xE4isi t\\xE4lt\\xE4: \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"Example\\noverride: Derived Class\\n\")), mdx(\"h2\", {\n    \"id\": \"olion-varsinainen-tyyppi-määrittää-käytetyn-metodin\"\n  }, \"Olion varsinainen tyyppi m\\xE4\\xE4ritt\\xE4\\xE4 k\\xE4ytetyn metodin\"), mdx(\"p\", null, \"Olion tyyppi m\\xE4\\xE4ritt\\xE4\\xE4, mit\\xE4 metodeja olion k\\xE4yt\\xF6ss\\xE4 on. Luodaan pari esimerkki\\xE4 t\\xE4st\\xE4.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"namespace Exercise001\\n{\\n  public class Person\\n  {\\n    public string name { get; set; }\\n    public string address { get; set; }\\n\\n    public Person(string name, string address)\\n    {\\n      this.name = name;\\n      this.address = address;\\n    }\\n\\n    public override string ToString()\\n    {\\n      return this.name + \\\", \\\" + this.address;\\n    }\\n  }\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"namespace Exercise001\\n{\\n  public class Student : Person\\n  {\\n    public int credits { get; set; }\\n    public Student(string name, string address) : base(name, address)\\n    {\\n      this.credits = 0;\\n    }\\n\\n    public void Study()\\n    {\\n      this.credits++;\\n    }\\n  }\\n}\\n\")), mdx(\"p\", null, \"Jos viittaus \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Student\"), \"-tyyppiseen olioon tallennetaan \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Person\"), \"-tyyppiseen muuttujaan, k\\xE4ytett\\xE4viss\\xE4 ovat vain \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Person\"), \"-luokassa (ja sen yliluokissa ja toteuttamissa rajapinnoissa) m\\xE4\\xE4ritellyt metodit:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"Person ollie = new Student(\\\"Ollie\\\", \\\"6381 Hollywood Blvd. Los Angeles 90028\\\");\\n\\nConsole.WriteLine(ollie.credits);       // EI TOIMI!\\nollie.Study();              // EI TOIMI!\\nConsole.WriteLine(ollie);   // ollie.ToString() TOIMII\\n\")), mdx(\"p\", null, \"Saamme virheen kahdesta ensimm\\xE4isest\\xE4 kutsusta \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"ollie\"), \"-oliolle.\"), mdx(\"p\", null, \"Eli oliolla on k\\xE4yt\\xF6ss\\xE4\\xE4n metodit, jotka liittyv\\xE4t sen tyyppiin, sek\\xE4 sen yliluokkiin ja toteuttamiinsa rajapintoihin. Yll\\xE4 olevassa esimerkiss\\xE4 \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Student\"), \"-tyyppisell\\xE4 oliolla on k\\xE4yt\\xF6ss\\xE4\\xE4n metodit, jotka on m\\xE4\\xE4ritelty luokissa \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Person\"), \" ja \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Object\"), \".\"), mdx(\"p\", null, \"Annetaan Student-luokalle oma ToString:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"public override string ToString()\\n{\\n  return base.ToString() + \\\" credits: \\\" + this.credits;\\n}\\n\")), mdx(\"p\", null, \"Luokka Person on jo yliajanut ToString-metodin, joka on peritty luokasta Object, ja nyt yliajamme sen uudelleen luokassa Student. Jos k\\xE4sittelemme oliota jollain muulla tyypill\\xE4 kuin sen varsinaisella tyypill\\xE4, mit\\xE4 versiota olion metodista kutsutaan?\"), mdx(\"p\", null, \"Seuraavassa esimerkiss\\xE4 meill\\xE4 on opiskelijoita, joita viittaamme muuttujilla eri tyypeill\\xE4. Mik\\xE4 versio ToString-metodista suoritetaan: se, joka on m\\xE4\\xE4ritelty luokassa Object, Person vai Student?\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"Student ollie = new Student(\\\"Ollie\\\", \\\"6381 Hollywood Blvd. Los Angeles 90028\\\");\\nConsole.WriteLine(ollie);\\nPerson olliePerson = new Student(\\\"Ollie\\\", \\\"6381 Hollywood Blvd. Los Angeles 90028\\\");\\nConsole.WriteLine(olliePerson);\\nObject ollieObject = new Student(\\\"Ollie\\\", \\\"6381 Hollywood Blvd. Los Angeles 90028\\\");\\nConsole.WriteLine(ollieObject);\\n\\nObject alice = new Student(\\\"Alice\\\", \\\"177 Stewart Ave. Farmington, ME 04938\\\");\\nConsole.WriteLine(alice);\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"Ollie, 6381 Hollywood Blvd. Los Angeles 90028 credits: 0\\nOllie, 6381 Hollywood Blvd. Los Angeles 90028 credits: 0\\nOllie, 6381 Hollywood Blvd. Los Angeles 90028 credits: 0\\nAlice, 177 Stewart Ave. Farmington, ME 04938 credits: 0\\n\")), mdx(\"p\", null, \"Suoritettava metodi valitaan olion varsinaisen tyypin perusteella, eli sen luokan, jonka konstruktori kutsuttiin olion luomiseksi. Jos metodia ei ole m\\xE4\\xE4ritelty varsinaisessa tyypiss\\xE4, valitaan metodi luokasta joka on l\\xE4hinn\\xE4 varsinaista tyyppi\\xE4 perint\\xE4hierarkiassa.\"), mdx(\"p\", null, \"Riippumatta muuttujan tyypist\\xE4, metodi joka suoritetaan on aina olion varsinaisen tyypin m\\xE4\\xE4rittelem\\xE4 metodi. Oliot ovat \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"polymorfisia\"), \", mik\\xE4 tarkoittaa ett\\xE4 niit\\xE4 voidaan k\\xE4ytt\\xE4\\xE4 monenlaisilla muuttujatyypeill\\xE4. Suoritettava metodi valitaan aina olion varsinaisen tyypin perusteella. T\\xE4t\\xE4 ilmi\\xF6t\\xE4 kutsutaan \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"polymorfismiksi\"), \".\"), mdx(\"p\", null, \"Tarkastellaan polymorfismia toisessa esimerkiss\\xE4. \"), mdx(\"p\", null, \"Voisit esitt\\xE4\\xE4 pistett\\xE4 (Point) kaksiulotteisessa koordinaatistossa seuraavalla luokalla:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"namespace Exercise001\\n{\\n  using System;\\n  public class Point\\n  {\\n\\n    private int x;\\n    private int y;\\n\\n    public Point(int x, int y)\\n    {\\n      this.x = x;\\n      this.y = y;\\n    }\\n\\n    public int ManhattanDistanceFromOrigin()\\n    {\\n      return Math.Abs(x) + Math.Abs(y);\\n    }\\n\\n    protected string Location()\\n    {\\n      return x + \\\", \\\" + y;\\n    }\\n\\n    public override string ToString()\\n    {\\n      return \\\"(\\\" + this.Location() + \\\") distance \\\" + this.ManhattanDistanceFromOrigin();\\n    }\\n  }\\n}\\n\")), mdx(\"p\", null, \"Metodia \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Location\"), \" ei ole tarkoitettu ulkoiseen k\\xE4ytt\\xF6\\xF6n, mink\\xE4 vuoksi se on m\\xE4\\xE4ritelty suojatuksi, protected. Johdetut luokat voivat silti k\\xE4ytt\\xE4\\xE4 metodia. \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"http://en.wiktionary.org/wiki/Manhattan_distance\"\n  }, mdx(\"strong\", {\n    parentName: \"a\"\n  }, \"Manhattanin et\\xE4isyys\")), \" tarkoittaa et\\xE4isyytt\\xE4 kahden pisteen v\\xE4lill\\xE4, jos voit liikkua vain koordinaattiakselien suuntaisesti. Sit\\xE4 k\\xE4ytet\\xE4\\xE4n monissa navigointialgoritmeissa.\"), mdx(\"p\", null, \"V\\xE4rillinen piste on muutoin samanlainen kuin piste, mutta se sis\\xE4lt\\xE4\\xE4 my\\xF6s v\\xE4rin, joka on merkkijono. Samankaltaisuuden vuoksi voimme luoda uuden luokan laajentamalla luokkaa Point.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"namespace Exercise001\\n{\\n  public class ColorPoint : Point\\n  {\\n\\n    private string color;\\n\\n    public ColorPoint(int x, int y, string color) : base(x, y)\\n    {\\n      this.color = color;\\n    }\\n\\n    public override string ToString()\\n    {\\n      return base.ToString() + \\\" color: \\\" + color;\\n    }\\n  }\\n}\\n\")), mdx(\"p\", null, \"Luokka m\\xE4\\xE4ritt\\xE4\\xE4 oliomuuttujan johon tallennamme v\\xE4rin. Koordinaatit on jo m\\xE4\\xE4ritelty yliluokassa. Haluamme, ett\\xE4 merkkijonoesitys on sama kuin pisteill\\xE4, mutta ett\\xE4 se sis\\xE4lt\\xE4\\xE4 my\\xF6s tiedon v\\xE4rin. Yliajettu \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"ToString\"), \"-metodi kutsuu yliluokan \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"ToString\"), \"-metodia ja lis\\xE4\\xE4 siihen pisteen v\\xE4rin.\"), mdx(\"p\", null, \"Seuraavaksi lis\\xE4\\xE4mme muutaman pisteen listaan. Osa niist\\xE4 on \\\"normaaleja\\\" pisteit\\xE4, kun taas toiset ovat v\\xE4rillisi\\xE4 pisteit\\xE4. Esimerkin lopussa tulostamme listan pisteet. Jokaiselle pisteelle suoritettava \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"ToString\"), \"-metodi m\\xE4\\xE4r\\xE4ytyy pisteen varsinaisen tyypin perusteella, vaikka lista tiet\\xE4\\xE4 kaikki pisteet tyypin Point perusteella.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"static void Main(string[] args)\\n{\\n  List<Point> points = new List<Point>();\\n  points.Add(new Point(4, 8));\\n  points.Add(new ColorPoint(1, 1, \\\"green\\\"));\\n  points.Add(new ColorPoint(2, 5, \\\"blue\\\"));\\n  points.Add(new Point(0, 0));\\n\\n  foreach (Point p in points)\\n  {\\n    Console.WriteLine(p);\\n  }\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"(4, 8) distance 12\\n(1, 1) distance 2 color: green\\n(2, 5) distance 7 color: blue\\n(0, 0) distance 0\\n\")), mdx(\"p\", null, \"Haluamme lis\\xE4t\\xE4 ohjelmaamme my\\xF6s kolmiulotteisen pisteen. Koska sill\\xE4 ei ole v\\xE4ri\\xE4, johdamme sen luokasta \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Point\"), \".\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"namespace Exercise001\\n{\\n  using System;\\n  public class Point3D : Point\\n  {\\n\\n    private int z;\\n\\n    public Point3D(int x, int y, int z) : base(x, y)\\n    {\\n      this.z = z;\\n    }\\n    new protected string Location()\\n    {\\n      return base.Location() + \\\", \\\" + z;    // merkkijono on muotoa \\\"x, y, z\\\"\\n    }\\n    new public int ManhattanDistanceFromOrigin()\\n    {\\n      // ensin kysyt\\xE4\\xE4n yliluokalta et\\xE4isyys x:n ja y:n perusteella\\n      // lis\\xE4t\\xE4\\xE4n siihen z-koordinaatin vaikutus\\n      return base.ManhattanDistanceFromOrigin() + Math.Abs(z);\\n    }\\n\\n    public override string ToString()\\n    {\\n      return \\\"(\\\" + this.Location() + \\\") distance \\\" + this.ManhattanDistanceFromOrigin();\\n    }\\n  }\\n}\\n\")), mdx(Note, {\n    mdxType: \"Note\"\n  }, \"Metodeissamme Location ja ManhattanDistanceFromOrigin k\\xE4yt\\xE4mme avainsanaa new, koska yliajamme metodit yliluokasta. Ilman avainsanaa saamme varoituksen.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"static void Main(string[] args)\\n{\\n  List<Point> points = new List<Point>();\\n  points.Add(new Point(4, 8));\\n  points.Add(new ColorPoint(1, 1, \\\"green\\\"));\\n  points.Add(new ColorPoint(2, 5, \\\"blue\\\"));\\n  points.Add(new Point3D(5, 2, 8));\\n  points.Add(new Point(0, 0));\\n\\n  foreach (Point p in points)\\n  {\\n    Console.WriteLine(p);\\n  }\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"(4, 8) distance 12\\n(1, 1) distance 2 color: green\\n(2, 5) distance 7 color: blue\\n(5, 2, 8) distance 15\\n(0, 0) distance 0\\n\")), mdx(\"p\", null, \"Huomaamme, ett\\xE4 \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Point3D\"), \"-luokan \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"ToString\"), \"-metodi on t\\xE4sm\\xE4lleen sama kuin \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Point\"), \"-luokan \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"ToString\"), \". Voisimmeko s\\xE4\\xE4st\\xE4\\xE4 vaivaa ja olla yliajamatta \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"ToString\"), \"-metodia? Vastaus on kyll\\xE4! \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Point3D\"), \"-luokkaa muokataan seuraavasti:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"namespace Exercise001\\n{\\n  using System;\\n  public class Point3D : Point\\n  {\\n\\n    private int z;\\n\\n    public Point3D(int x, int y, int z) : base(x, y)\\n    {\\n      this.z = z;\\n    }\\n    new protected string Location()\\n    {\\n      return base.Location() + \\\", \\\" + z;    // the resulting string has the form \\\"x, y, z\\\"\\n    }\\n    new public int ManhattanDistanceFromOrigin()\\n    {\\n      return base.ManhattanDistanceFromOrigin() + Math.Abs(z);\\n    }\\n  }\\n}\\n\")), mdx(\"p\", null, \"Mit\\xE4 tarkalleenottaen tapahtuu kun kutsutaan kolmiulotteisen pisteen ToString-metodia? Suoritus etenee seuraavasti.\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Etsit\\xE4\\xE4n luokan Point3D m\\xE4\\xE4ritelm\\xE4st\\xE4 ToString-metodia. Sit\\xE4 ei l\\xF6ydy, joten seuraavaksi tarkastellaan yliluokkaa.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Etsit\\xE4\\xE4n luokan Point m\\xE4\\xE4ritelm\\xE4st\\xE4 ToString-metodia. Se l\\xF6ytyy, joten metodi suoritetaan.\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"tarkalleen ottaen koodi joka suoritetaan on \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"return \\\"(\\\"+this.Location()+\\\") distance \\\" + this.ManhattanDistanceFromOrigin();\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"metodi \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Location\"), \" suoritetaan ensin\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Etsit\\xE4\\xE4n luokan Point3D m\\xE4\\xE4ritelm\\xE4st\\xE4 Location-metodia. Se l\\xF6ytyy, joten metodi suoritetaan.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"T\\xE4m\\xE4 metodi kutsuu yliluokan \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Location\"), \"-metodia, joka on m\\xE4\\xE4ritelty luokassa Point. \"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"seuraavaksi etsimme luokan Point m\\xE4\\xE4ritelm\\xE4st\\xE4 \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"ManhattanDistanceFromOrigin\"), \"-metodia. Se l\\xF6ytyy, joten metodi suoritetaan.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"J\\xE4lleen kerran t\\xE4m\\xE4 metodi kutsuu yliluokan \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"ManhattanDistanceFromOrigin\"), \"-metodia.\")), mdx(\"p\", null, \"Kuten n\\xE4emme, tapahtumien kulku on melko monivaiheinen. Tapahtumien kulku on kuitenkin selke\\xE4: metodi etsit\\xE4\\xE4n ensin varsinaisen tyypin m\\xE4\\xE4ritelm\\xE4st\\xE4, ja jos sit\\xE4 ei l\\xF6ydy, etsit\\xE4\\xE4n yliluokasta. T\\xE4m\\xE4 jatkuu kunnes metodi l\\xF6ytyy tai kunnes yliluokkaa ei en\\xE4\\xE4 ole.\"), mdx(\"h2\", {\n    \"id\": \"milloin-perintää-kannattaa-käyttää\"\n  }, \"Milloin perint\\xE4\\xE4 kannattaa k\\xE4ytt\\xE4\\xE4?\"), mdx(\"p\", null, \"Perint\\xE4 on ty\\xF6kalu, joka on tarkoitettu hierarkioiden rakentamiseen ja erikoistapauksien luomiseen. Johdettu luokka on aina yliluokan erikoistapaus. Jos luokka, joka on tarkoitus luoda, on erikoistapaus olemassaolevasta luokasta, t\\xE4m\\xE4 uusi luokka voitaisiin luoda laajentamalla olemassaolevaa luokkaa. Esimerkiksi edell\\xE4 k\\xE4sitellyss\\xE4 auton osien hallintaj\\xE4rjestelm\\xE4ss\\xE4 moottori on osa, mutta sill\\xE4 on my\\xF6s ominaisuuksia, joita osalla ei ole, kuten moottorin tyyppi. T\\xE4ll\\xF6in moottori on erikoistapaus osasta.\"), mdx(\"p\", null, \"Kun perit\\xE4\\xE4n, johdettu luokka saa yliluokan toiminnallisuudet. Jos johdettu luokka ei tarvitse tai k\\xE4yt\\xE4 jotain yliluokan toiminnallisuutta, perint\\xE4\\xE4 ei ole perusteltua k\\xE4ytt\\xE4\\xE4. Luokat, jotka periv\\xE4t, periv\\xE4t kaikki yliluokan metodit ja rajapinnat, joten johdettua luokkaa voidaan k\\xE4ytt\\xE4\\xE4 yliluokan sijasta kaikkialla, miss\\xE4 yliluokkaa k\\xE4ytet\\xE4\\xE4n. On hyv\\xE4 pit\\xE4\\xE4 perint\\xE4hierarkia matalana, koska sen yll\\xE4pito ja kehitt\\xE4minen vaikeutuu, mit\\xE4 suuremmaksi se kasvaa. Yleisesti ottaen, jos perint\\xE4hierarkia on yli 2-3 tasoa syv\\xE4, ohjelman rakennetta kannattaa harkita uudelleen.\"), mdx(\"p\", null, \"Perint\\xE4 ei ole hyv\\xE4 ratkaisu kaikissa tilanteissa. Esimerkiksi luokkaa Car ei kannata laajentaa luokalla Part (tai Engine). Auto sis\\xE4lt\\xE4\\xE4 moottorin ja osia, mutta moottori tai osa ei ole auto. Yleisesti ottaen, jos luokka omistaa tai koostuu muista luokista, perint\\xE4\\xE4 ei kannata k\\xE4ytt\\xE4\\xE4.\"), mdx(\"p\", null, \"Kun k\\xE4ytet\\xE4\\xE4n perint\\xE4\\xE4, kannattaa huolehtia, ett\\xE4 \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Yhden Vastuun Periaate\"), \" (englanniksi \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://en.wikipedia.org/wiki/Single_responsibility_principle\"\n  }, mdx(\"strong\", {\n    parentName: \"a\"\n  }, \"Single Responsibility Principle\")), \") pit\\xE4\\xE4 paikkansa. Jokaisella luokalla pit\\xE4isi olla vain yksi syy muuttua. Jos huomaat, ett\\xE4 perint\\xE4 lis\\xE4\\xE4 luokan vastuuta, kannattaa luokka jakaa useammaksi luokaksi.\"), mdx(\"h3\", {\n    \"id\": \"esimerkkejä-perinnän-väärinkäytöstä\"\n  }, \"Esimerkkej\\xE4 perinn\\xE4n v\\xE4\\xE4rink\\xE4yt\\xF6st\\xE4\"), mdx(\"p\", null, \"Tarkastellaan postipalvelua ja siihen liittyvi\\xE4 luokkia. \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Customer\"), \" sis\\xE4lt\\xE4\\xE4 asiakkaaseen liittyv\\xE4t tiedot, ja luokka \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Order\"), \", joka perii luokan Customer ja sis\\xE4lt\\xE4\\xE4 tilattuun tuotteeseen liittyv\\xE4t tiedot. Luokalla Order on my\\xF6s metodi \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"PostalAddress\"), \", joka kuvaa tilauksen toimitusosoitetta.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"public class Customer\\n{\\n  public string name { get; set; }\\n  public string address { get; set; }\\n\\n  public Customer(string name, string address)\\n  {\\n    this.name = name;\\n    this.address = address;\\n  }\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"public class Order : Customer\\n{\\n\\n  private string product;\\n  private string count;\\n\\n  public Order(string product, string count, string name, string address) : base(name, address)\\n  {\\n    this.product = product;\\n    this.count = count;\\n  }\\n\\n  public string PostalAddress()\\n  {\\n    return this.name + \\\"\\\\n\\\" + this.address;\\n  }\\n}\\n\")), mdx(\"p\", null, \"Yll\\xE4 perint\\xE4\\xE4 ei k\\xE4ytet\\xE4 oikein. Kun perit\\xE4\\xE4n, johdettu luokka on aina yliluokan erikoistapaus: tilaus ei ole asiakas. V\\xE4\\xE4rink\\xE4yt\\xF6s n\\xE4kyy siin\\xE4, miten koodi rikkoo \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Yhden Vastuun Periaatetta\"), \". Luokka \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Order\"), \" on vastuussa sek\\xE4 asiakkaan ett\\xE4 tilauksen tiedoista.\"), mdx(\"p\", null, \"Ongelma tulee selv\\xE4ksi, kun ajattelemme, mit\\xE4 asiakkaan osoitteen muuttaminen aiheuttaisi.\"), mdx(\"p\", null, \"Jos asiakkaan osoite muuttuu, meid\\xE4n pit\\xE4isi muuttaa jokaista Order-oliota jotka liittyv\\xE4t asiakkaaseen. T\\xE4m\\xE4 ei ole l\\xE4hesk\\xE4\\xE4n ideaalia. Parempi ratkaisu olisi kapseloida asiakas \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Customer\"), \"-luokan muuttujaksi \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Order\"), \"-luokassa. T\\xE4m\\xE4 on intuitiivisempaa, koska nyt jokaisella tilauksella on asiakas.\"), mdx(\"p\", null, \"Muokataan \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Order\"), \"-luokkaa niin, ett\\xE4 se sis\\xE4lt\\xE4\\xE4 viittauksen \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Customer\"), \"-luokkaan.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"public class Order\\n{\\n\\n  private Customer customer;\\n  private string product;\\n  private string count;\\n\\n  public Order(Customer customer, string product, string count)\\n  {\\n    this.customer = customer;\\n    this.product = product;\\n    this.count = count;\\n  }\\n\\n  public string PostalAddress()\\n  {\\n    return this.customer.name + \\\"\\\\n\\\" + this.customer.address;\\n  }\\n}\\n\")), mdx(\"p\", null, \"T\\xE4m\\xE4 versio \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Order\"), \"-luokasta on parempi. Metodi \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"PostalAddress\"), \" k\\xE4ytt\\xE4\\xE4 asiakkaan tietoja, mutta ei periydy asiakkaasta. T\\xE4m\\xE4 auttaa sek\\xE4 ohjelman yll\\xE4pitoa ett\\xE4 sen toiminnallisuutta.\"), mdx(\"p\", null, \"Nyt jos asiakkaan osoite muuttuu, meid\\xE4n tarvitsee muuttaa vain asiakasta. T\\xE4m\\xE4 on paljon helpompaa kuin muuttaa jokaista tilausta erikseen.\"), mdx(\"h2\", {\n    \"id\": \"abstraktit-luokat\"\n  }, \"Abstraktit luokat\"), mdx(\"p\", null, \"Aina v\\xE4lill\\xE4 kun suunnittelemme perint\\xE4hierarkiaa, on olemassa tapauksia, joissa on olemassa selke\\xE4 k\\xE4site, mutta se ei ole hyv\\xE4 ehdokas itsen\\xE4iseksi olioksi. K\\xE4site olisi hy\\xF6dyllinen perint\\xE4hierarkiassa, koska se sis\\xE4lt\\xE4\\xE4 muuttujia ja toiminnallisuutta, jotka ovat jaettuja kaikille luokille, jotka periv\\xE4t sen. Toisaalta, ei ole tarkoituksenmukaista luoda instansseja itse k\\xE4sitteest\\xE4.\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Abstrakti luokka\"), \" (englanniksi \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"abstract class\"), \") yhdist\\xE4\\xE4 rajapinnan ja perinn\\xE4n. Et voi luoda instansseja abstraktista luokasta -- voit vain luoda instansseja luokista, jotka periv\\xE4t abstraktin luokan. Abstrakti luokka voi sis\\xE4lt\\xE4\\xE4 normaaleja metodeita joilla on metodin runko, mutta se voi my\\xF6s sis\\xE4lt\\xE4\\xE4 abstrakteja metodeja, joilla on vain metodin m\\xE4\\xE4ritelm\\xE4. Abstraktin luokan perivien luokkien vastuulla on toteuttaa abstraktit metodit. Yleens\\xE4 abstrakteja luokkia k\\xE4ytet\\xE4\\xE4n tilanteissa, joissa on olemassa selke\\xE4 k\\xE4site, mutta se ei ole itsen\\xE4inen olio. T\\xE4llaisessa tapauksessa ei tulisi siis luoda oliota kyseisest\\xE4 k\\xE4sitteest\\xE4.\"), mdx(\"p\", null, \"M\\xE4\\xE4ritell\\xE4ksemme abstraktin luokan k\\xE4yt\\xE4mme avainsanaa \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"abstract\"), \". Abstrakti luokka m\\xE4\\xE4ritell\\xE4\\xE4n lausekkeella \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"public abstract class \", mdx(\"em\", {\n    parentName: \"strong\"\n  }, \"LuokanNimi\")), \". Abstrakti metodi m\\xE4\\xE4ritell\\xE4\\xE4n lausekkeella \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"public abstract paluuTyyppi MetodinNimi\"), \". Seuraavassa esimerkiss\\xE4 m\\xE4\\xE4ritell\\xE4\\xE4n abstrakti luokka \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Operation\"), \", joka tarjoaa rakenteen operaatioille ja niiden suorittamiselle.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"namespace Exercise001\\n{\\n  public abstract class Operation\\n  {\\n\\n    public string name { get; }\\n\\n    public Operation(string name)\\n    {\\n      this.name = name;\\n    }\\n\\n    public abstract void Execute();\\n  }\\n}\\n\")), mdx(\"p\", null, \"Abstrakti luokka \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Operation\"), \" toimii pohjana erilaisten toimintojen toteuttamiselle. Voit esimerkiksi toteuttaa plus-toiminnon laajentamalla \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Operation\"), \"-luokkaa seuraavasti.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"namespace Exercise001\\n{\\n  using System;\\n  public class PlusOperation : Operation\\n  {\\n    public PlusOperation() : base(\\\"PlusOperation\\\")\\n    {\\n    }\\n\\n    public override void Execute()\\n    {\\n      Console.Write(\\\"First number: \\\");\\n      int first = Convert.ToInt32(Console.ReadLine());\\n      Console.Write(\\\"Second number: \\\");\\n      int second = Convert.ToInt32(Console.ReadLine());\\n\\n      Console.WriteLine(\\\"The sum of the numbers is \\\" + (first + second));\\n    }\\n  }\\n}\\n\")), mdx(\"p\", null, \"Koska kaikki luokat, jotka periv\\xE4t \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Operation\"), \"-luokan, ovat my\\xF6s tyypilt\\xE4\\xE4n \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Operation\"), \", voimme luoda k\\xE4ytt\\xF6liittym\\xE4n k\\xE4ytt\\xE4m\\xE4ll\\xE4 \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Operation\"), \"-tyyppisi\\xE4 muuttujia. Seuraavassa esimerkiss\\xE4 n\\xE4yt\\xE4mme luokan \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"UserInterface\"), \", joka sis\\xE4lt\\xE4\\xE4 listan toimintoja. K\\xE4ytt\\xF6liittym\\xE4\\xE4n voidaan lis\\xE4t\\xE4 toimintoja dynaamisesti.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"namespace Exercise001\\n{\\n  using System;\\n  using System.Collections.Generic;\\n  public class UserInterface\\n  {\\n\\n    private List<Operation> operations;\\n\\n    public UserInterface()\\n    {\\n      this.operations = new List<Operation>();\\n    }\\n\\n    public void AddOperation(Operation operation)\\n    {\\n      this.operations.Add(operation);\\n    }\\n\\n    public void Start()\\n    {\\n      while (true)\\n      {\\n        PrintOperations();\\n        Console.WriteLine(\\\"Choice: \\\");\\n\\n        string choice = Console.ReadLine();\\n        if (choice == \\\"0\\\")\\n        {\\n          break;\\n        }\\n\\n        ExecuteOperation(choice);\\n        Console.WriteLine();\\n      }\\n    }\\n\\n    private void PrintOperations()\\n    {\\n      Console.WriteLine(\\\"\\\\t0: Stop\\\");\\n      int i = 0;\\n      while (i < this.operations.Count)\\n      {\\n        string operationName = this.operations[i].name;\\n        Console.WriteLine(\\\"\\\\t\\\" + (i + 1) + \\\": \\\" + operationName);\\n        i = i + 1;\\n      }\\n    }\\n\\n    private void ExecuteOperation(string choice)\\n    {\\n      int operation = Convert.ToInt32(choice);\\n\\n      Operation chosen = this.operations[operation -1];\\n      chosen.Execute();\\n    }\\n  }\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"UserInterface userInterface = new UserInterface();\\nuserInterface.AddOperation(new PlusOperation());\\n\\nuserInterface.Start();\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"        0: Stop\\n        1: PlusOperation\\nChoice:\\n> 1\\nFirst number: 4\\nSecond number: 5\\nThe sum of the numbers is 9\\n\\n        0: Stop\\n        1: PlusOperation\\nChoice:\\n> 0\\n\")), mdx(\"p\", null, \"Suurin ero rajapintojen ja abstraktien luokkien v\\xE4lill\\xE4 on, ett\\xE4 abstraktit luokat voivat sis\\xE4lt\\xE4\\xE4 oliomuuttujia ja konstruktoreita metodeiden lis\\xE4ksi. Koska voit my\\xF6s m\\xE4\\xE4ritell\\xE4 toiminnallisuutta abstrakteissa luokissa, voit k\\xE4ytt\\xE4\\xE4 niit\\xE4 m\\xE4\\xE4rittelem\\xE4\\xE4n esimerkiksi oletusk\\xE4ytt\\xE4ytymist\\xE4. K\\xE4ytt\\xF6liittym\\xE4ss\\xE4 yll\\xE4 olevassa esimerkiss\\xE4 k\\xE4ytet\\xE4\\xE4n abstraktissa luokassa m\\xE4\\xE4ritelty\\xE4 oliomuuttujaa \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"name\"), \". T\\xE4m\\xE4 mahdollistaa toimintojen nimen tallentamisen ja tulostamisen.\"), mdx(\"h1\", {\n    \"id\": \"tehtävät\"\n  }, \"Teht\\xE4v\\xE4t\"), mdx(Exercise, {\n    title: '001 ABC',\n    mdxType: \"Exercise\"\n  }, mdx(\"p\", null, \"Luo seuraavat kolme luokkaa:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Luokka A. Luokalla ei ole oliomuuttujia eik\\xE4 konstruktoria. Luokalla on ainoastaan metodi \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"public void APrint()\"), \", joka tulostaa merkkijonon \\\"A\\\".\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Luokka B. Luokalla ei ole oliomuuttujia eik\\xE4 konstruktoria. Luokalla on ainoastaan metodi \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"public void BPrint()\"), \", joka tulostaa merkkijonon \\\"B\\\".\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Luokka C. Luokalla ei ole oliomuuttujia eik\\xE4 konstruktoria. Luokalla on ainoastaan metodi \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"public void CPrint()\"), \", joka tulostaa merkkijonon \\\"C\\\".\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Kun olet luonut luokat, \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"muokkaa niit\\xE4\"), \" niin, ett\\xE4 luokka B perii luokan A, ja luokka C perii luokan B. Toisin sanoen luokka A on luokan B kantaluokka, ja luokka B on luokan C kantaluokka.\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"A a = new A();\\nB b = new B();\\nC c = new C();\\n\\na.APrint();\\nb.BPrint();\\nc.CPrint();\\n\\nConsole.WriteLine();\\n\\nc.APrint();\\nc.BPrint();\\nc.CPrint();\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"A\\nB\\nC\\n\\nA\\nB\\nC\\n\"))), mdx(Exercise, {\n    title: '002 Person and Subclasses',\n    mdxType: \"Exercise\"\n  }, mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Osa 1\")), mdx(\"p\", null, \"Luo luokka \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Person\"), \". Luokan tulee toimia seuraavasti:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"Person ada = new Person(\\\"Ada Lovelace\\\", \\\"24 Maddox St. London W1S 2QN\\\");\\nPerson esko = new Person(\\\"Esko Ukkonen\\\", \\\"Mannerheimintie 15 00100 Helsinki\\\");\\nConsole.WriteLine(ada);\\nConsole.WriteLine(esko);\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"Ada Lovelace, 24 Maddox St. London W1S 2QN\\nEsko Ukkonen, Mannerheimintie 15 00100 Helsinki\\n\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Osa 2\")), mdx(\"p\", null, \"Luo luokka \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Student\"), \", joka perii luokan \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Person\"), \".\"), mdx(\"p\", null, \"Luodessa oliota, opiskelijalla on 0 opintopistett\\xE4. Joka kerta kun opiskelija opiskelee, opintopisteiden m\\xE4\\xE4r\\xE4 kasvaa. Luokan tulee toimia seuraavasti:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"Student ollie = new Student(\\\"Ollie\\\", \\\"6381 Hollywood Blvd. Los Angeles 90028\\\");\\nConsole.WriteLine(ollie);\\nollie.Study();\\nConsole.WriteLine(ollie);\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"Ollie, 6381 Hollywood Blvd. Los Angeles 90028 credits: 0\\nOllie, 6381 Hollywood Blvd. Los Angeles 90028 credits: 1\\n\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Osa 3\")), mdx(\"p\", null, \"Luo luokka \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Teacher\"), \", joka perii luokan \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Person\"), \".\"), mdx(\"p\", null, \"Luokan tulee toimia seuraavasti:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"Teacher ada = new Teacher(\\\"Ada Lovelace\\\", \\\"24 Maddox St. London W1S 2QN\\\", 1200);\\nTeacher esko = new Teacher(\\\"Esko Ukkonen\\\", \\\"Mannerheimintie 15 00100 Helsinki\\\", 5400);\\nConsole.WriteLine(ada);\\nConsole.WriteLine(esko);\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"Ada Lovelace, 24 Maddox St. London W1S 2QN salary 1200 per month\\nEsko Ukkonen, Mannerheimintie 15 00100 Helsinki salary 5400 per month\\n\")), mdx(Note, {\n    mdxType: \"Note\"\n  }, \"Sinun pit\\xE4\\xE4 yliajaa ToString-metodi kaikissa luokissa. Luokaisa Student ja Teacher k\\xE4yt\\xE4 base.ToString() l\\xE4ht\\xF6kohtana.\")), mdx(Exercise, {\n    title: '003 Warehousing',\n    mdxType: \"Exercise\"\n  }, mdx(\"p\", null, \"Teht\\xE4v\\xE4pohjassa on luokka \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Warehouse\"), \", joka sis\\xE4lt\\xE4\\xE4 seuraavat ominaisuudet, konstruktorin ja metodit:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"public int balance - varaston saldo, eli kuinka paljon tilaa varastossa olevat asiat k\\xE4ytt\\xE4v\\xE4t.\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"public int capacity - varaston kapasiteetti, eli kuinka paljon tilaa varastossa on yhteens\\xE4 (joka annettiin konstruktorissa).\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"constructor public Warehouse(int capacity) - Luo tyhj\\xE4n varaston, jolla on annettu kapasiteetti; virheellinen kapasiteetti (<=0) luo k\\xE4ytt\\xF6kelvottoman varaston, jonka kapasiteetti on 0.\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"public int HowMuchSpaceLeft() - Palauttaa arvon, joka kertoo kuinka paljon tilaa varastossa on j\\xE4ljell\\xE4.\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"public void AddToWarehouse(int amount) - Lis\\xE4\\xE4 varastoon halutun m\\xE4\\xE4r\\xE4n; jos m\\xE4\\xE4r\\xE4 on negatiivinen, ei tapahdu mit\\xE4\\xE4n, ja jos kaikki ei mahdu, varasto t\\xE4ytet\\xE4\\xE4n ja loput \\\"heitet\\xE4\\xE4n pois\\\"/\\\"ylivuotavat\\\".\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"public int TakeFromWarehouse(int amount) - Ottaa varastosta halutun m\\xE4\\xE4r\\xE4n; jos m\\xE4\\xE4r\\xE4 on negatiivinen, ei tapahdu mit\\xE4\\xE4n ja palautetaan 0, ja jos m\\xE4\\xE4r\\xE4 on suurempi kuin varastossa oleva m\\xE4\\xE4r\\xE4, palautetaan kaikki mit\\xE4 varastossa on ja varasto tyhjennet\\xE4\\xE4n.\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"public override string ToString() - Palauttaa olion tilan merkkijonona seuraavassa muodossa:\"))), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"balance: 64, space left 16\\n\")), mdx(\"p\", null, \"Teht\\xE4v\\xE4ss rakennamme varastosta erilaisia variaatioita Warehouse-luokan pohjalta.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Osa 1\")), mdx(\"p\", null, \"Luokka \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Warehouse\"), \" k\\xE4sittelee tuotteiden m\\xE4\\xE4r\\xE4\\xE4. Nyt haluamme tuotteelle nimen ja tavan k\\xE4sitell\\xE4 sit\\xE4. Kirjoita \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"ProductWarehouse\"), \" luokka, joka perii \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Warehouse\"), \"-luokan! Luodaan ensin yksityinen oliomuuttuja tuotteen nimelle ja konstruktori:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"public string productName\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"public ProductWarehouse(string productName, int capacity) - Luo tyhj\\xE4n tuotevaraston. Tuotteen nimi ja varaston kapasiteetti annetaan parametreina.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"public override string ToString() - Palauttaa olion tilan merkkijonona kuten esimerkiss\\xE4 alla:\")), mdx(Note, {\n    mdxType: \"Note\"\n  }, \"Muistele, miten konstruktori voi k\\xE4ytt\\xE4\\xE4 yliluokan konstruktoria, jotta ymm\\xE4rr\\xE4t olemassaolevaa koodia!\"), mdx(\"p\", null, \"Esimerkkitoiminnallisuus:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"ProductWarehouse juice = new ProductWarehouse(\\\"Juice\\\", 1000);\\njuice.AddToWarehouse(1000);\\njuice.TakeFromWarehouse(11);\\nConsole.WriteLine(juice.productName); // Juice\\nConsole.WriteLine(juice);\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"Juice\\nJuice: balance: 989, space left 11\\n\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Osa 2\")), mdx(\"p\", null, \"Luodaan informatiivisempi varasto. Haluamme tiet\\xE4\\xE4, jos ja miten tuotteen saldo on muuttunut. Luodaan ensin ty\\xF6kalu muutoshistorialle, ja luodaan luokka \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"ChangeHistory\"), \":\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"private List<int\", \">\", \" history\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"constructor public ChangeHistory() \"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"public void Add(int status) - lis\\xE4\\xE4 annetun tilan viimeisimp\\xE4n\\xE4 summana muutoshistoriaan\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"public void Clear() - tyhjent\\xE4\\xE4 muutoshistorian\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"public int MaxValue() - palauttaa suurimman arvon muutoshistoriassa; jos historia on tyhj\\xE4, palauttaa 0\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"public int MinValue() - palauttaa pienimm\\xE4n arvon muutoshistoriassa; jos historia on tyhj\\xE4, palauttaa 0\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"public override string ToString() - palauttaa seuraavanlaisen merkkijonon:\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"Current: 500 Min: 0 Max: 1000\\n\")), mdx(\"p\", null, \"Merkkijonoss ensimm\\xE4inen numero on varaston saldo (listan viimeinen indeksi), toinen numero on pienin numero listalla, ja viimeinen on suurin numero listalla.\"), mdx(Note, {\n    mdxType: \"Note\"\n  }, \"K\\xE4yt\\xE4 MaxValue ja MinValue metodeja ToString-metodissasi!\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Osa 3\")), mdx(\"p\", null, \"Toteuta \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"ProductWarehouseWithHistory\"), \" luokka, joka perii \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"ProductWarehouse\"), \"-luokan. T\\xE4m\\xE4 uusi varasto tarjoaa lis\\xE4ksi palveluita varaston muutoshistorian k\\xE4sittelyyn. Historiaa hallitaan \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"ChangeHistory\"), \"-olion avulla.\"), mdx(\"p\", null, \"Julkiset konstruktorit ja metodit:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"public ProductWarehouseWithHistory(string productName, int capacity, int initialBalance) - Luo tuotevaraston. Tuotteen nimi, kapasiteetti ja alkusaldo annetaan parametreina. Alkusaldo asetetaan varaston saldoksi, sek\\xE4 ensimm\\xE4iseksi arvoksi muutoshistoriaan.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"public string History() - palauttaa tuotteen muutoshistorian seuraavasti:\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"Current: 500 Min: 0 Max: 1000\\n\")), mdx(\"p\", null, \"K\\xE4yt\\xE4 ChangeHistory-luokan ToString-metodia sellaisenaan.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"uusi public void AddToWarehouse(int amount) - toimii kuten ProductWarehouse-luokan vastaava metodi, mutta lis\\xE4\\xE4 my\\xF6s muutoshistoriaan uuden arvon. HUOM! Muutoshistoriaan tulee lis\\xE4t\\xE4 varaston saldo lis\\xE4yksen j\\xE4lkeen, ei lis\\xE4tt\\xE4v\\xE4\\xE4 m\\xE4\\xE4r\\xE4\\xE4!\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"uusi public int TakeFromWarehouse(int amount) - toimii kuten ProductWarehouse-luokan vastaava metodi, mutta lis\\xE4\\xE4 my\\xF6s muutoshistoriaan uuden arvon. HUOM! Muutoshistoriaan tulee lis\\xE4t\\xE4 varaston saldo poiston j\\xE4lkeen, ei poistettavaa m\\xE4\\xE4r\\xE4\\xE4!\")), mdx(\"p\", null, \"T\\xE4ss\\xE4 yksi massiivinen esimerkki:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"Warehouse wh = new Warehouse(100);\\nConsole.WriteLine(wh);\\nwh.AddToWarehouse(10);\\nConsole.WriteLine(wh);\\nwh.AddToWarehouse(100);\\nConsole.WriteLine(wh);\\nwh.AddToWarehouse(-10);\\nConsole.WriteLine(wh);\\nwh.TakeFromWarehouse(20);\\nConsole.WriteLine(wh);\\nwh.TakeFromWarehouse(-20);\\nConsole.WriteLine(wh);\\n\\nConsole.WriteLine();\\n\\nProductWarehouse juice = new ProductWarehouse(\\\"Juice\\\", 1000);\\njuice.AddToWarehouse(1000);\\njuice.TakeFromWarehouse(11);\\nConsole.WriteLine(juice.productName); // Juice\\nConsole.WriteLine(juice);\\n\\nConsole.WriteLine();\\n\\nChangeHistory cs = new ChangeHistory();\\ncs.Add(100);\\ncs.Add(10);\\ncs.Add(200);\\ncs.Add(50);\\nConsole.WriteLine(cs);\\n\\nConsole.WriteLine();\\n\\nProductWarehouseWithHistory milk = new ProductWarehouseWithHistory(\\\"Milk\\\", 1000, 100);\\nConsole.WriteLine(milk);\\nmilk.TakeFromWarehouse(10);\\nConsole.WriteLine(milk.History());\\nConsole.WriteLine(milk);\\nmilk.AddToWarehouse(100);\\nConsole.WriteLine(milk.History());\\nConsole.WriteLine(milk);\\nmilk.TakeFromWarehouse(-10000);\\nConsole.WriteLine(milk.History());\\nConsole.WriteLine(milk);\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"balance: 0, space left 100\\nbalance: 10, space left 90\\nbalance: 100, space left 0\\nbalance: 100, space left 0\\nbalance: 80, space left 20\\nbalance: 80, space left 20\\n\\nJuice\\nJuice: balance: 989, space left 11\\n\\nCurrent: 50 Min: 10 Max: 200\\n\\nMilk: balance: 100, space left 900\\nCurrent: 90 Min: 90 Max: 100\\nMilk: balance: 90, space left 910\\nCurrent: 190 Min: 90 Max: 190\\nMilk: balance: 190, space left 810\\nCurrent: 190 Min: 90 Max: 190\\nMilk: balance: 190, space left 810\\n\"))), mdx(Exercise, {\n    title: '004 Different Boxes',\n    mdxType: \"Exercise\"\n  }, mdx(\"p\", null, \"Harjoituspohjassa on luokat \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Item\"), \" ja \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Box\"), \". Box on abstrakti luokka, jossa useiden esineiden lis\\xE4\\xE4minen on toteutettu toistamalla \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Add-metodia\"), \". Add-metodi, joka on tarkoitettu yhden esineen lis\\xE4\\xE4miseen, on abstrakti, joten jokaisen luokan, joka perii sen, t\\xE4ytyy toteuttaa se. Teht\\xE4v\\xE4si on muokata Box-luokkaa ja toteuttaa erilaisia laatikoita Box-luokan pohjalta.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Osa 1\")), mdx(\"p\", null, \"Toteuta metodit \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Equals\"), \" ja \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"GetHashCode\"), \" luokalle \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Item\"), \". Ne ovat tarpeen, jotta voit k\\xE4ytt\\xE4\\xE4 eri listojen ja kokoelmien Contains-metodeja. \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Toteuta metodit siten, ett\\xE4 Item-luokan painon arvoa ei oteta huomioon.\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Osa 2\")), mdx(\"p\", null, \"Toteuta luokka \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"BoxWithMaxWeight\"), \", joka perii luokan \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Box\"), \". BoxWithMaxWeight-luokalla on konstruktori \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"public BoxWithMaxWeight(int capacity)\"), \", joka m\\xE4\\xE4rittelee laatikon maksimipainon. Voit lis\\xE4t\\xE4 esineit\\xE4 laatikkoon, jos ja vain jos lis\\xE4ys ei ylit\\xE4 laatikon maksimipainoa. \"), mdx(\"p\", null, \"Seuraavaksi toteuta luokka \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"OneItemBox\"), \", joka perii luokan \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Box\"), \". OneItemBox-luokalla on konstruktori \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"public OneItemBox()\"), \", ja sen kapasiteetti on tasan yksi esine. Jos laatikkoon on jo lis\\xE4tty esine, sit\\xE4 ei vaihdeta. Esineen paino ei ole t\\xE4rke\\xE4.\"), mdx(\"p\", null, \"Seuraavaksi toteuta luokka \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"MisplacingBox\"), \", joka perii luokan \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Box\"), \". MisplacingBox-luokalla on konstruktori \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"public MisplacingBox()\"), \". Voit lis\\xE4t\\xE4 mit\\xE4 tahansa esineit\\xE4 laatikkoon, mutta esineit\\xE4 ei koskaan l\\xF6ydy laatikosta. Toisin sanoen laatikkoon lis\\xE4\\xE4minen onnistuu aina, mutta \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"IsInBox\"), \"-metodi palauttaa aina arvon \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"false\"), \".\"), mdx(\"p\", null, \"T\\xE4ss\\xE4 hieman koodia kaiken testaamiseen:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"BoxWithMaxWeight coffeeBox = new BoxWithMaxWeight(10);\\ncoffeeBox.Add(new Item(\\\"Saludo\\\", 5));\\ncoffeeBox.Add(new Item(\\\"Pirkka\\\", 5));\\ncoffeeBox.Add(new Item(\\\"Kopi Luwak\\\", 5));\\n\\nConsole.WriteLine(coffeeBox.IsInBox(new Item(\\\"Saludo\\\")));\\nConsole.WriteLine(coffeeBox.IsInBox(new Item(\\\"Pirkka\\\")));\\nConsole.WriteLine(coffeeBox.IsInBox(new Item(\\\"Kopi Luwak\\\")));\\n\\nOneItemBox box = new OneItemBox();\\nbox.Add(new Item(\\\"Saludo\\\", 5));\\nbox.Add(new Item(\\\"Pirkka\\\", 5));\\n\\nConsole.WriteLine(box.IsInBox(new Item(\\\"Saludo\\\")));\\nConsole.WriteLine(box.IsInBox(new Item(\\\"Pirkka\\\")));\\n\\nMisplacingBox mbox = new MisplacingBox();\\nConsole.WriteLine(mbox.IsInBox(new Item(\\\"Saludo\\\")));\\nConsole.WriteLine(mbox.IsInBox(new Item(\\\"Pirkka\\\")));\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"True\\nTrue\\nFalse\\nTrue\\nFalse\\nFalse\\nFalse\\n\"))));\n}\n;\nMDXContent.isMDXComponent = true;","tableOfContents":{"items":[{"items":[{"url":"#suojausmääreet-private-protected-ja-public","title":"Suojausmääreet private, protected ja public"},{"url":"#konstruktorin-kutsuminen-yliluokasta","title":"Konstruktorin kutsuminen yliluokasta"},{"url":"#yliluokan-metodin-kutsuminen","title":"Yliluokan metodin kutsuminen"},{"url":"#olion-varsinainen-tyyppi-määrittää-käytetyn-metodin","title":"Olion varsinainen tyyppi määrittää käytetyn metodin"},{"url":"#milloin-perintää-kannattaa-käyttää","title":"Milloin perintää kannattaa käyttää?","items":[{"url":"#esimerkkejä-perinnän-väärinkäytöstä","title":"Esimerkkejä perinnän väärinkäytöstä"}]},{"url":"#abstraktit-luokat","title":"Abstraktit luokat"}]},{"url":"#tehtävät","title":"Tehtävät"}]},"frontmatter":{"title":"Perintä"}}},"pageContext":{"id":"dc9a6d02-b374-5340-963c-4a0d1198b320"}},
    "staticQueryHashes": ["1885717130","1950529541","2744905544","3020054368"]}