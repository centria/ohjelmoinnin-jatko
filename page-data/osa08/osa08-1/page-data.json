{
    "componentChunkName": "component---src-templates-docs-js",
    "path": "/osa08/osa08-1",
    "result": {"data":{"mdx":{"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Hakemistot\",\n  \"nav_order\": 81,\n  \"hidden\": false\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar Exercise = makeShortcode(\"Exercise\");\nvar Note = makeShortcode(\"Note\");\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Yksi useimmin k\\xE4ytetyist\\xE4 tietorakenteista listojen ohella on \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"hakemisto\"), \" (englanniksi \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"dictionary\"), \"). C#-kielell\\xE4 \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"hhttps://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.dictionary-2?view=net-6.0\"\n  }, mdx(\"strong\", {\n    parentName: \"a\"\n  }, \"Dictionary<TKey,TValue> luokka\")), \" sijaitsee \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"System.Collections.Generic\"), \"-nimisess\\xE4 \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"nimiavaruudessa\"), \". Mutta mit\\xE4 se tekee?\"), mdx(\"p\", null, \"Hakemistossa data on tallennettu \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"avain-arvo pareihin\"), \", joissa arvoja voidaan lis\\xE4t\\xE4, hakea ja poistaa avaimien avulla.\"), mdx(\"p\", null, \"Alla olevassa esimerkiss\\xE4 on luotu hakemisto, joka etsii kaupunkeja postinumeroiden perusteella, jonka j\\xE4lkeen hakemistoon on lis\\xE4tty nelj\\xE4 postinumero-kaupunki-paria. Lopuksi hakemistosta haetaan postinumero \\\"00710\\\". Sek\\xE4 postinumero ett\\xE4 kaupunki on esitetty merkkijonoina.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"using System;\\nusing System.Collections.Generic;\\n\\nnamespace Exercise001\\n{\\n  class Program\\n  {\\n    static void Main(string[] args)\\n    {\\n      Dictionary<string, string> postalCodes = new Dictionary<string, string>();\\n      postalCodes.Add(\\\"00710\\\", \\\"Helsinki\\\");\\n      postalCodes.Add(\\\"90014\\\", \\\"Oulu\\\");\\n      postalCodes.Add(\\\"33720\\\", \\\"Tampere\\\");\\n      postalCodes.Add(\\\"33014\\\", \\\"Tampere\\\");\\n\\n      Console.WriteLine(postalCodes[\\\"33720\\\"]);\\n    }\\n  }\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"Tampere\\n\")), mdx(\"p\", null, \"Hakemiston sis\\xE4inen tila yll\\xE4 luodussa hakemistossa n\\xE4ytt\\xE4\\xE4 t\\xE4lt\\xE4. Jokainen avain viittaa johonkin arvoon.\"), mdx(\"p\", null, mdx(\"img\", {\n    parentName: \"p\",\n    \"src\": \"https://raw.githubusercontent.com/centria/ohjelmoinnin-jatko/master/src/images//part8-1-dict.png\",\n    \"alt\": \"Dictionary\"\n  })), mdx(\"p\", null, \"Jos hakee hakemistosta avaimella, jota ei ole hakemistossa, saadaan \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"KeyNotFoundException\"), \".\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"Dictionary<string, string> postalCodes = new Dictionary<string, string>();\\npostalCodes.Add(\\\"00710\\\", \\\"Helsinki\\\");\\npostalCodes.Add(\\\"90014\\\", \\\"Oulu\\\");\\npostalCodes.Add(\\\"33720\\\", \\\"Tampere\\\");\\npostalCodes.Add(\\\"33014\\\", \\\"Tampere\\\");\\n\\nConsole.WriteLine(postalCodes[\\\"67100\\\"]);\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"Unhandled exception. System.Collections.Generic.KeyNotFoundException: The given key '67100' was not present in the dictionary.\\n   at System.Collections.Generic.Dictionary`2.get_Item(TKey key)\\n   at Exercise001.Program.Main(String[] args) in /mnt/c/Users/HeikkiHei/Documents/coding-exercises/Exercise001/Program.cs:line 17\\n\")), mdx(\"p\", null, \"Hakemiston luomisessa tarvitaan kaksi tyyppiparametria - avaimen tyyppi ja lis\\xE4tt\\xE4v\\xE4n arvon tyyppi. Jos hakemiston avaimet ovat merkkijonoja ja arvot kokonaislukuja, luodaan hakemisto seuraavasti\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"Dictionary<string, integer> dict = new Dictionary<string, integer>();\\n\")), mdx(\"p\", null, \"Hakemistoon lis\\xE4\\xE4minen tehd\\xE4\\xE4n \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Add(avain, arvo)\"), \"-metodilla, jolla on kaksi parametria, toinen avaimelle, toinen arvolle. Hakemistosta hakeminen tehd\\xE4\\xE4n tutulla \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"hakemisto\", \"[avain]\"), \"-syntaksilla. T\\xE4ll\\xE4 kertaa etsit\\xE4\\xE4n arvoa avaimen perusteella, eik\\xE4 indeksin.\"), mdx(\"h2\", {\n    \"id\": \"hakemiston-avaimet-vastaa-enintään-yhtä-arvoa\"\n  }, \"Hakemiston avaimet vastaa enint\\xE4\\xE4n yht\\xE4 arvoa\"), mdx(\"p\", null, \"Hakemistossa on enint\\xE4\\xE4n yksi arvo per avain. Jos hakemistoon lis\\xE4t\\xE4\\xE4n uusi avain-arvo-pari, mutta avaimella on jo hakemistossa jokin toinen arvo, saadaan \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"ArgumentException\"), \".\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"Dictionary<string, string> postalCodes = new Dictionary<string, string>();\\npostalCodes.Add(\\\"67100\\\", \\\"Kokkola\\\");\\npostalCodes.Add(\\\"67100\\\", \\\"Karleby\\\");\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"Unhandled exception. System.ArgumentException: An item with the same key has already been added. Key: 67100\\n   at System.Collections.Generic.Dictionary`2.TryInsert(TKey key, TValue value, InsertionBehavior behavior)\\n   at System.Collections.Generic.Dictionary`2.Add(TKey key, TValue value)\\n\")), mdx(\"p\", null, \"Voimme varautua t\\xE4h\\xE4n tarkistamalla, onko arvoa jo olemassa hakemistossa, ja lis\\xE4\\xE4mme uuden arvon vain, jos sit\\xE4 ei ole:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"Dictionary<string, string> postalCodes = new Dictionary<string, string>();\\npostalCodes.Add(\\\"00710\\\", \\\"Helsinki\\\");\\npostalCodes.Add(\\\"90014\\\", \\\"Oulu\\\");\\npostalCodes.Add(\\\"33720\\\", \\\"Tampere\\\");\\npostalCodes.Add(\\\"33014\\\", \\\"Tampere\\\");\\npostalCodes.Add(\\\"67100\\\", \\\"Kokkola\\\");\\npostalCodes.Add(\\\"99999\\\", null);\\n\\nif (!postalCodes.ContainsKey(\\\"67100\\\"))\\n{\\n  postalCodes.Add(\\\"67100\\\", \\\"Karleby\\\");\\n}\\n\")), mdx(\"p\", null, \"T\\xE4ten varmistamme ettei ohjelmamme kaadu, kun yrit\\xE4mme vaihtaa arvoa \\\"67100\\\". N\\xE4hd\\xE4ksemme mit\\xE4 hakemistomme sis\\xE4lt\\xE4\\xE4, voimme k\\xE4ytt\\xE4\\xE4 foreach-silmukkaa \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"KeyValuePair\"), \"-olioille:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"foreach (KeyValuePair<string, string> kvp in postalCodes)\\n{\\n  Console.WriteLine(\\\"Key = {0}, Value = {1}\\\",\\n      kvp.Key, kvp.Value);\\n}\\n\")), mdx(\"p\", null, \"Tulostus on seuraava:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"Key = 00710, Value = Helsinki\\nKey = 90014, Value = Oulu\\nKey = 33720, Value = Tampere\\nKey = 33014, Value = Tampere\\nKey = 67100, Value = Kokkola\\nKey = 99999, Value = \\n\")), mdx(\"p\", null, \"Huomannet hieman erilaisen tulostuksen merkkijonolle. Yll\\xE4 k\\xE4ytimme \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/tokens/interpolated\"\n  }, \"Merkkijonon interpolointia\"), \" (englanniksi \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"String interpolation\"), \").\"), mdx(\"p\", null, \"Kuten n\\xE4emme, voimme lis\\xE4t\\xE4 hakemistoon my\\xF6s \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"null\"), \"-arvon. Emme kuitenkaan voi antaa \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"null\"), \"-arvoa avaimelle, tai saamme \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"ArgumentNullException\"), \".\"), mdx(\"h2\", {\n    \"id\": \"viittaustyyppinen-muuttuja-hakemiston-arvona\"\n  }, \"Viittaustyyppinen muuttuja hakemiston arvona\"), mdx(\"p\", null, \"Tarkastellaan seuraavaksi kuinka hakemisto toimii, k\\xE4ytt\\xE4en kirjastoa esimerkkin\\xE4. Jos kirja l\\xF6ytyy annetulla hakusanalla, kirjasto palauttaa viittauksen kirjaan. Aloitetaan luomalla esimerkki-luokka \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Book\"), \", jolla on nimi, sis\\xE4lt\\xF6 ja julkaisuvuosi instanssimuuttujina.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"public class Book\\n{\\n  public string name { get; set; }\\n  public string content { get; set; }\\n  public int published { get; set; }\\n\\n  public Book(string name, int published, string content)\\n  {\\n    this.name = name;\\n    this.published = published;\\n    this.content = content;\\n  }\\n\\n  public override string ToString()\\n  {\\n    return \\\"Name: \\\" + this.name + \\\" (\\\" + this.published + \\\")\\\\n\\\"\\n        + \\\"Content: \\\" + this.content;\\n  }\\n}\\n\")), mdx(\"p\", null, \"Luodaan hakemisto joka k\\xE4ytt\\xE4\\xE4 kirjan nime\\xE4 avaimena, eli merkkijonoa, ja arvona kirjaa itse\\xE4\\xE4n.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"Dictionary<string, Book> directory = new Dictionary<string, Book>();\\n\")), mdx(\"p\", null, \"Yll\\xE4 oleva hakemisto k\\xE4ytt\\xE4\\xE4 avaimena \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"merkkijonoa\"), \". Laajennetaan esimerkki\\xE4 niin, ett\\xE4 hakemistoon lis\\xE4t\\xE4\\xE4n kaksi kirjaa, \\\"Sense and Sensibility\\\" ja \\\"Pride and Predujice\\\".\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"Book senseAndSensibility = new Book(\\\"Sense and Sensibility\\\", 1811, \\\"...\\\");\\nBook prideAndPredujice = new Book(\\\"Pride and Prejudice\\\", 1813, \\\"....\\\");\\n\\nDictionary<string, Book> directory = new Dictionary<string, Book>();\\ndirectory.Add(senseAndSensibility.name, senseAndSensibility);\\ndirectory.Add(prideAndPredujice.name, prideAndPredujice);\\n\")), mdx(\"p\", null, \"Kirjoja voidaan hakea hakemistosta kirjan nimell\\xE4. Hakusanalla \\\"Persuation\\\" ei l\\xF6ydy mit\\xE4\\xE4n, jolloin hakemisto antaa virheen. Kirja \\\"Pride and Prejudice\\\" l\\xF6ytyy kuitenkin. Pelataan varman p\\xE4\\xE4lle, ja laitetaan molemmat if-lauseen sis\\xE4\\xE4n:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"if (directory.ContainsKey(\\\"Persuation\\\"))\\n{\\n  Console.WriteLine(directory[\\\"Persuasion\\\"]);\\n}\\nelse\\n{\\n  Console.WriteLine(\\\"Book not found!\\\");\\n}\\n\\nConsole.WriteLine();\\nif (directory.ContainsKey(\\\"Pride and Prejudice\\\"))\\n{\\n  Console.WriteLine(directory[\\\"Pride and Prejudice\\\"]);\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"Book not found!\\n\\nName: Pride and Prejudice (1813)\\nContent: ....\\n\")), mdx(\"h2\", {\n    \"id\": \"milloin-hakemistoja-kannattaa-käyttää\"\n  }, \"Milloin hakemistoja kannattaa k\\xE4ytt\\xE4\\xE4?\"), mdx(\"p\", null, \"Hakemisto on toteutettu siten, ett\\xE4 avaimella hakeminen on eritt\\xE4in nopeaa. Hakemisto luo avaimesta \\\"hash-arvon\\\", eli koodinp\\xE4tk\\xE4n, jota k\\xE4ytet\\xE4\\xE4n arvon tallentamiseen tiettyyn paikkaan. Kun hakemistosta haetaan avaimella tietoa, kyseinen koodinp\\xE4tk\\xE4 tunnistaa paikan, jossa avaimen arvo sijaitsee. K\\xE4yt\\xE4nn\\xF6ss\\xE4 ei ole tarvetta k\\xE4yd\\xE4 l\\xE4pi kaikkia avain-arvo-pareja hakemistossa, kun etsit\\xE4\\xE4n avaimella tietoa; tarkistettava joukko on huomattavasti pienempi.\"), mdx(\"p\", null, \"Mietit\\xE4\\xE4n yll\\xE4 olevaa kirjasto-esimerkki\\xE4. Koko ohjelma voitaisiin toteuttaa my\\xF6s listalla. T\\xE4ll\\xF6in kirjat laitettaisiin listalle hakemiston sijaan, ja kirjojen haku tapahtuisi k\\xE4ym\\xE4ll\\xE4 l\\xE4pi lista.\"), mdx(\"p\", null, \"Alla olevassa esimerkiss\\xE4 kirjat on tallennettu listaan, ja niiden hakeminen tapahtuu listaa l\\xE4pik\\xE4ym\\xE4ll\\xE4.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"List<Book> books = new List<Book>();\\nBook senseAndSensibility = new Book(\\\"Sense and Sensibility\\\", 1811, \\\"...\\\");\\nBook prideAndPrejudice = new Book(\\\"Pride and Prejudice\\\", 1813, \\\"....\\\");\\nbooks.Add(senseAndSensibility);\\nbooks.Add(prideAndPrejudice);\\n\\n// etsit\\xE4\\xE4n kirjaa nimelt\\xE4 Persuation\\nforeach (Book book in books)\\n{\\n  if (book.name == \\\"Persuation\\\")\\n  {\\n    Console.WriteLine(book);\\n    break;\\n  }\\n}\\n\\nConsole.WriteLine();\\n// etsit\\xE4\\xE4n kirjaa nimelt\\xE4 Sense and Sensibility\\nforeach (Book book in books)\\n{\\n  if (book.name == \\\"Sense and Sensibility\\\")\\n  {\\n    Console.WriteLine(book);\\n    break;\\n  }\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"\\nName: Sense and Sensibility (1811)\\nContent: ...\\n\")), mdx(\"p\", null, \"Nyt ohjelma toimii aika lailla samalla tavalla kuin hakemistomme versio, eik\\xF6 vain?\"), mdx(\"p\", null, \"Toiminnallisesti, kyll\\xE4. Mietit\\xE4\\xE4n kuitenkin ohjelman suorituskyky\\xE4. C#-kielen \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"DateTime()\"), \"-luokalla on ominaisuus \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Ticks\"), \", joka kuvaa DateTime-instanssin annettua p\\xE4iv\\xE4m\\xE4\\xE4r\\xE4\\xE4 ja aikaa. Tick on sata nanosekuntia.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"List<Book> books = new List<Book>();\\n\\n// lis\\xE4t\\xE4\\xE4n 10 miljoonaa kirjaa listaan\\n\\nBook senseAndSensibility = new Book(\\\"Sense and Sensibility\\\", 1811, \\\"...\\\");\\nBook prideAndPrejudice = new Book(\\\"Pride and Prejudice\\\", 1813, \\\"....\\\");\\nbooks.Add(senseAndSensibility);\\nbooks.Add(prideAndPrejudice);\\n\\nDateTime start = DateTime.Now;\\n\\n// etsit\\xE4\\xE4n kirjaa nimelt\\xE4 Persuation\\nforeach (Book book in books)\\n{\\n  if (book.name == \\\"Persuation\\\")\\n  {\\n    Console.WriteLine(book);\\n    break;\\n  }\\n}\\n\\nConsole.WriteLine();\\n\\n// etist\\xE4\\xE4n kirjaa nimelt\\xE4 Sense and Sensibility\\nforeach (Book book in books)\\n{\\n  if (book.name == \\\"Sense and Sensibility\\\")\\n  {\\n    Console.WriteLine(book);\\n    break;\\n  }\\n}\\nDateTime end = DateTime.Now;\\nConsole.WriteLine(\\\"Time elapsed: \\\" + (end.Ticks - start.Ticks)/10000.0 + \\\" milliseconds\\\");\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"Name: Sense and Sensibility (1811)\\nContent: ...\\nTime elapsed: 390.5467 millisecond\\n\")), mdx(\"p\", null, \"Kun kirjoja on 10 miljoonaa (ja 2), kest\\xE4\\xE4 l\\xE4hes puoli sekuntia l\\xF6yt\\xE4\\xE4 kaksi kirjaa. Tietysti listan j\\xE4rjestys vaikuttaa siihen, kuinka nopeasti ohjelma toimii. Jos etsitt\\xE4v\\xE4 kirja olisi ensimm\\xE4isen\\xE4 listalla, ohjelma olisi nopeampi. Toisaalta, jos kirjaa ei olisi listalla, ohjelma joutuisi k\\xE4ym\\xE4\\xE4n l\\xE4pi kaikki listan kirjat ennen kuin se tiet\\xE4isi, ettei kirjaa ole listalla.\"), mdx(\"p\", null, \"Mietit\\xE4\\xE4n samaa ohjelmaa hakemistolla toteutettuna.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"\\nDictionary<string, Book> directory = new Dictionary<string, Book>();\\n\\n// Add 10 million books to the dictionary\\n\\nBook senseAndSensibility = new Book(\\\"Sense and Sensibility\\\", 1811, \\\"...\\\");\\nBook prideAndPredujice = new Book(\\\"Pride and Prejudice\\\", 1813, \\\"....\\\");\\ndirectory.Add(senseAndSensibility.name, senseAndSensibility);\\ndirectory.Add(prideAndPredujice.name, prideAndPredujice);\\n\\nDateTime start = DateTime.Now;\\n\\nif (directory.ContainsKey(\\\"Persuation\\\"))\\n{\\n  Console.WriteLine(directory[\\\"Persuasion\\\"]);\\n}\\nelse\\n{\\n  Console.WriteLine(\\\"Book not found!\\\");\\n}\\n\\nConsole.WriteLine();\\nif (directory.ContainsKey(\\\"Pride and Prejudice\\\"))\\n{\\n  Console.WriteLine(directory[\\\"Pride and Prejudice\\\"]);\\n}\\n\\nDateTime end = DateTime.Now;\\nConsole.WriteLine(\\\"Time elapsed: \\\" + (end.Ticks - start.Ticks)/10000.0 + \\\" milliseconds\\\");\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"Book not found!\\n\\nName: Pride and Prejudice (1813)\\nContent: ....\\nTime elapsed: 5.8134 milliseconds\\n\")), mdx(\"p\", null, \"Kuten huomataan, hakemisto on melko paljon nopeampi, ja se on vain 2 kirjaa. Mit\\xE4 jos  etsitt\\xE4vi\\xE4 kirjoja olisi 3? Ent\\xE4 100?\"), mdx(\"h2\", {\n    \"id\": \"hakemisto-instanssimuuttujana\"\n  }, \"Hakemisto instanssimuuttujana\"), mdx(\"p\", null, \"Yll\\xE4 oleva esimerkki kirjojen tallentamiseen on ongelmallinen, sill\\xE4 nimen kirjoitusasu on muistettava tarkasti. Joku saattaa etsi\\xE4 kirjaa pienell\\xE4 alkukirjaimella, toinen isolla, tai joku voi esimerkiksi painaa v\\xE4lily\\xF6nti\\xE4 ennen kuin alkaa kirjoittaa nime\\xE4. Katsotaan seuraavaksi hieman anteeksi antavampaa tapaa etsi\\xE4 kirjoja nimen perusteella.\"), mdx(\"p\", null, \"K\\xE4yt\\xE4mme hy\\xF6dyksi merkkijono-luokan tarjoamia ty\\xF6kaluja merkkijonojen k\\xE4sittelyyn. \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"ToLower()\"), \"-metodi luo uuden merkkijonon, jossa kaikki kirjaimet on muutettu pieniksi kirjaimiksi. \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Trim()\"), \"-metodi puolestaan luo uuden merkkijonon, josta on poistettu tyhj\\xE4t merkit merkkijonon alusta ja lopusta.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"string text = \\\"Pride and Prejudice     \\\";\\ntext = text.ToLower(); // text on nyt \\\"pride and prejudice     \\\"\\ntext = text.Trim(); // text on ny \\\"pride and prejudice\\\"\\n\")), mdx(\"p\", null, \"Merkkijonon muunnos yll\\xE4 olevan esimerkin mukaisesti johtaa siihen, ett\\xE4 kirja l\\xF6ytyy, vaikka k\\xE4ytt\\xE4j\\xE4 kirjoittaisi kirjan nimen pienill\\xE4 kirjaimilla.\"), mdx(\"p\", null, \"Luodaan kirjastoluokka (nimelt\\xE4\\xE4n Library) joka kapseloi hakemiston, joka sis\\xE4lt\\xE4\\xE4 kirjoja, ja mahdollistaa kirjojen hakemisen nimen perusteella. Lis\\xE4\\xE4mme kirjastoluokkaan metodit kirjojen lis\\xE4\\xE4miseen, hakemiseen ja poistamiseen. Jokainen n\\xE4ist\\xE4 perustuu sanitisoituun nimeen - t\\xE4m\\xE4 tarkoittaa nimen muuttamista pieniksi kirjaimiksi ja tyhjien merkkien poistamista alusta ja lopusta.\"), mdx(\"p\", null, \"Luodaan ensin hahmotelma metodille kirjan lis\\xE4\\xE4mist\\xE4 varten. Kirja lis\\xE4t\\xE4\\xE4n hakemistoon k\\xE4ytt\\xE4en nime\\xE4 avaimena ja kirjaa itse\\xE4\\xE4n arvona. Koska haluamme sallia pienten kirjainten k\\xE4yt\\xF6n kirjan nimess\\xE4, muutamme nimen pieniksi kirjaimiksi. Lis\\xE4ksi poistamme tyhj\\xE4t merkit nimen alusta ja lopusta.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"public class Library\\n{\\n  private Dictionary<string, Book> directory;\\n\\n  public Library()\\n  {\\n    this.directory = new Dictionary<string, Book>();\\n  }\\n\\n  public void AddBook(Book book)\\n  {\\n    string name = book.name;\\n    if (name == null)\\n    {\\n      name = \\\"\\\";\\n    }\\n\\n    name = name.ToLower();\\n    name = name.Trim();\\n\\n    if (this.directory.ContainsKey(name))\\n    {\\n      Console.WriteLine(\\\"Book is already in the library!\\\");\\n    }\\n    else\\n    {\\n      directory.Add(name, book);\\n    }\\n  }\\n}\\n\")), mdx(\"p\", null, \"Metodi \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"ContainsKey\"), \" hakemistossa tarkistaa, onko hakemistossa jo avain, joka vastaa parametrina annettua avainta. Jos avain l\\xF6ytyy, metodi palauttaa \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"true\"), \", muuten \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"false\"), \".\"), mdx(\"p\", null, \"Voimme jo nyt n\\xE4hd\\xE4, ett\\xE4 merkkijonon sanitointia tarvitaan jokaisessa kirjastoluokan metodissa, joka k\\xE4sittelee kirjan nime\\xE4. T\\xE4m\\xE4 tekee hyv\\xE4st\\xE4 ehdokkaasta erillisen apumetodin. Metodi toteutetaan luokkametodina, koska se ei k\\xE4sittele oliomuuttujia.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"public static string SanitizedString(string input)\\n{\\n  if (input == null)\\n  {\\n    return \\\"\\\";\\n  }\\n\\n  input = input.ToLower();\\n  return input.Trim();\\n}\\n\")), mdx(\"p\", null, \"Toteutus on paljon siistimpi kun apumetodia k\\xE4ytet\\xE4\\xE4n.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"using System;\\nusing System.Collections.Generic;\\n\\nnamespace Exercise001\\n{\\n  public class Library\\n  {\\n    private Dictionary<string, Book> directory;\\n\\n    public Library()\\n    {\\n      this.directory = new Dictionary<string, Book>();\\n    }\\n\\n    public void AddBook(Book book)\\n    {\\n      string name = SanitizedString(book.name);\\n\\n      if (this.directory.ContainsKey(name))\\n      {\\n        Console.WriteLine(\\\"Book is already in the library!\\\");\\n      }\\n      else\\n      {\\n        directory.Add(name, book);\\n      }\\n    }\\n\\n    public Book GetBook(string bookTitle)\\n    {\\n      bookTitle = SanitizedString(bookTitle);\\n      if (this.directory.ContainsKey(bookTitle))\\n      {\\n        return this.directory[bookTitle];\\n      }\\n      else\\n      {\\n        return null;\\n      }\\n    }\\n\\n    public void RemoveBook(string bookTitle)\\n    {\\n      bookTitle = SanitizedString(bookTitle);\\n\\n      if (this.directory.ContainsKey(bookTitle))\\n      {\\n        this.directory.Remove(bookTitle);\\n      }\\n      else\\n      {\\n        Console.WriteLine(\\\"Book was not found, cannot be removed!\\\");\\n      }\\n    }\\n\\n\\n    public static string SanitizedString(string input)\\n    {\\n      if (input == null)\\n      {\\n        return \\\"\\\";\\n      }\\n\\n      input = input.ToLower();\\n      return input.Trim();\\n    }\\n  }\\n}\\n\")), mdx(\"p\", null, \"Tarkastellaan t\\xE4t\\xE4 k\\xE4yt\\xE4nn\\xF6ss\\xE4\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"Book senseAndSensibility = new Book(\\\"Sense and Sensibility\\\", 1811, \\\"...\\\");\\nBook prideAndPredujice = new Book(\\\"Pride and Prejudice\\\", 1813, \\\"....\\\");\\n\\nLibrary library = new Library();\\nlibrary.AddBook(senseAndSensibility);\\nlibrary.AddBook(prideAndPredujice);\\n\\nConsole.WriteLine(library.GetBook(\\\"pride and prejudice\\\"));\\nConsole.WriteLine();\\n\\nConsole.WriteLine(library.GetBook(\\\"PRIDE AND PREJUDICE\\\"));\\nConsole.WriteLine();\\n\\nConsole.WriteLine(library.GetBook(\\\"SENSE\\\"));\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"Name: Pride and Prejudice (1813)\\nContent: ....\\n\\nName: Pride and Prejudice (1813)\\nContent: ....\\n\")), mdx(\"p\", null, \"Yll\\xE4 olevassa esimerkiss\\xE4 seurasimme \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"DRY (Don't Repeat Yourself)\"), \"-periaatetta, jonka mukaan koodin toisteisuutta tulisi v\\xE4ltt\\xE4\\xE4. Merkkijonon sanitointi, eli muuttaminen pieniksi kirjaimiksi ja tyhjien merkkien poistaminen alusta ja lopusta, olisi toistunut monessa kohdassa kirjastoluokkaamme ilman \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"SanitizedString\"), \"-metodia. Toistuva koodi ei useinkaan huomata ennen kuin se on jo kirjoitettu, mik\\xE4 tarkoittaa, ett\\xE4 se p\\xE4\\xE4tyy l\\xE4hes aina koodiin. T\\xE4ss\\xE4 ei ole mit\\xE4\\xE4n vikaa - t\\xE4rkeint\\xE4 on, ett\\xE4 koodi siistit\\xE4\\xE4n, jotta koodin siistimist\\xE4 vaativat kohdat huomataan.\"), mdx(\"h2\", {\n    \"id\": \"hakemiston-avainten-läpikäynti\"\n  }, \"Hakemiston avainten l\\xE4pik\\xE4ynti\"), mdx(\"p\", null, \"Joskus voi olla tarvetta etsi\\xE4 kirjaa vain nimen osan perusteella. Hakemistossa olevaa \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"get\"), \"-metodia (dictionary\", \"[\", \"key\", \"]\", \") ei voi k\\xE4ytt\\xE4\\xE4 t\\xE4ss\\xE4 tapauksessa, koska se on tarkoitettu tietyn avaimen hakemiseen. Kirjan nimen osan perusteella etsiminen ei ole mahdollista sen avulla.\"), mdx(\"p\", null, \"Voimme k\\xE4yd\\xE4 l\\xE4pi hakemiston avaimia k\\xE4ytt\\xE4m\\xE4ll\\xE4 for-each silmukkaa. Hakemiston \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Keys\"), \" ominaisuus palauttaa kaikki avaimet kokoelmana, \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"KeyCollection\"), \".\"), mdx(\"p\", null, \"Alla haemme kaikista kirjoista, joiden nimess\\xE4 on annettu merkkijono.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"public List<Book> GetBooksByPart(string titlePart)\\n{\\n  List<Book> books = new List<Book>();\\n  titlePart = SanitizedString(titlePart);\\n  Dictionary<string, Book>.KeyCollection keys = this.directory.Keys;\\n\\n  foreach (string bookTitle in keys)\\n  {\\n    if (bookTitle.Contains(titlePart))\\n    {\\n      books.Add(this.directory[bookTitle]);\\n    }\\n  }\\n  return books;\\n}\\n\")), mdx(\"p\", null, \"T\\xE4ll\\xE4 tapaa kuitenkin h\\xE4vit\\xE4mme hakemistojen mukana saavutetun nopeusedun. Hakemisto on toteutettu siten, ett\\xE4 yksitt\\xE4isen avaimen hakeminen on eritt\\xE4in nopeaa. Yll\\xE4 oleva esimerkki k\\xE4y l\\xE4pi kaikki kirjan nimet, kun etsit\\xE4\\xE4n yksitt\\xE4ist\\xE4 kirjaa tietyll\\xE4 avaimella.\"), mdx(\"h2\", {\n    \"id\": \"hakemiston-arvojen-läpikäynti\"\n  }, \"Hakemiston arvojen l\\xE4pik\\xE4ynti\"), mdx(\"p\", null, \"Aiempi toiminnallisuus voitaisiin toteuttaa my\\xF6s k\\xE4ym\\xE4ll\\xE4 l\\xE4pi hakemiston arvoja. Arvojen joukko (\", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"ValueCollection\"), \") voidaan hakea hakemiston \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Values()\"), \"-ominaisuudella. T\\xE4m\\xE4 arvojen joukko voidaan my\\xF6s k\\xE4yd\\xE4 l\\xE4pi for-each silmukalla.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"public List<Book> GetBooksByPart(string titlePart)\\n{\\n  List<Book> books = new List<Book>();\\n  titlePart = SanitizedString(titlePart);\\n  Dictionary<string, Book>.ValueCollection values = this.directory.Values;\\n\\n  foreach (Book book in values)\\n  {\\n    if (book.name.Contains(titlePart))\\n    {\\n      books.Add(book);\\n    }\\n  }\\n  return books;\\n}\\n\")), mdx(\"p\", null, \"Kuten edellisess\\xE4kin esimerkiss\\xE4, hakemistojen nopeushy\\xF6ty on nyt menetetty.\"), mdx(\"h1\", {\n    \"id\": \"tehtävät\"\n  }, \"Teht\\xE4v\\xE4t\"), mdx(Exercise, {\n    title: '001 Nicknames',\n    mdxType: \"Exercise\"\n  }, mdx(\"p\", null, \"Luo Main-metodiin uusi Dictionary<string, string> -olio. Tallenna seuraavan esimerkin nimet ja lempinimet t\\xE4h\\xE4n hakemistoon niin, ett\\xE4 nimi on avain ja lempinimi on arvo.\"), mdx(\"p\", null, \"Sen j\\xE4lkeen hae nimet hakemistosta ja tulosta seuraavasti:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"matthew's nickname is matt\\nmichael's nickname is mix\\narthur's nickname is artie\\n\")), mdx(\"p\", null, \"K\\xE4yt\\xE4 foreach-silmukkaa avain-arvo-parien (KeyValuePair) tulostamiseen.\")), mdx(Exercise, {\n    title: '002 Abbreviations',\n    mdxType: \"Exercise\"\n  }, mdx(\"p\", null, \"Luo luokka nimelt\\xE4 \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Abbreviations\"), \" yleisten lyhenteiden hallintaan. Luokalla tulee olla konstruktori, joka ei ota parametreja. Luokan tulee tarjota seuraavat metodit:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"public void AddAbbreviation(string abbreviation, string explanation)\"), \" lis\\xE4\\xE4 uuden lyhenteen ja sen selityksen.  Voit k\\xE4ytt\\xE4\\xE4 \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \".Add\"), \"-metodia hakemistolle ja olettaa, ett\\xE4 emme lis\\xE4\\xE4 samaa lyhennett\\xE4 kahdesti.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"public bool HasAbbreviation(string abbreviation)\"), \" tarkistaa, onko lyhennett\\xE4 jo lis\\xE4tty; palauttaa true, jos on ja false, jos ei.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"public string FindExplanationFor(string abbreviation)\"), \" l\\xF6yt\\xE4\\xE4 lyhenteen selityksen; palauttaa \\\"not found\\\" jos lyhennett\\xE4 ei ole lis\\xE4tty.\")), mdx(Note, {\n    mdxType: \"Note\"\n  }, \"K\\xE4yt\\xE4 HasAbbreviation-metodia FindExplanationFor-metodissa!\"), mdx(\"p\", null, \"Esimerkki k\\xE4yt\\xF6st\\xE4:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"Abbreviations abbreviations = new Abbreviations();\\nabbreviations.AddAbbreviation(\\\"e.g\\\", \\\"for example\\\");\\nabbreviations.AddAbbreviation(\\\"etc.\\\", \\\"and so on\\\");\\nabbreviations.AddAbbreviation(\\\"i.e\\\", \\\"more precisely\\\");\\n\\nstring text = \\\"e.g i.e etc. lol\\\";\\n\\nforeach (string part in text.Split(\\\" \\\"))\\n{\\n  Console.WriteLine(abbreviations.FindExplanationFor(part));\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"for example\\nand so on\\nmore precisely\\nnot found\\n\"))), mdx(Exercise, {\n    title: '003 Print Dictionary Keys',\n    mdxType: \"Exercise\"\n  }, mdx(\"p\", null, \"Teht\\xE4v\\xE4pohjassa on luokka \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Program\"), \". Toteuta luokkaan seuraavat luokkametodit:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"public static void PrintKeys(Dictionary<string,string> dict)\"), \", tulostaa kaikki avaimet hakemistosta, joka annetaan parametrina.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"public static void PrintKeysWhere(Dictionary<string,string> dict, string text)\"), \", tulostaa kaikki avaimet hakemistosta, joka annetaan parametrina, ja jotka sis\\xE4lt\\xE4v\\xE4t parametrina annetun merkkijonon.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"public static void PrintValuesOfKeysWhere(Dictionary<string,string> dict, string text)\"), \", tulostaa kaikki arvot hakemistosta, joka annetaan parametrina, ja joiden avaimet sis\\xE4lt\\xE4v\\xE4t parametrina annetun merkkijonon.\")), mdx(\"p\", null, \"Esimerkki luokan k\\xE4yt\\xF6st\\xE4\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"Dictionary<string,string> dict = new Dictionary<string, string>();\\ndict.Add(\\\"f.e\\\", \\\"for example\\\");\\ndict.Add(\\\"etc.\\\", \\\"and so on\\\");\\ndict.Add(\\\"i.e\\\", \\\"more precisely\\\");\\n\\nPrintKeys(dict);\\nConsole.WriteLine(\\\"---\\\");\\nPrintKeysWhere(dict, \\\"i\\\");\\nConsole.WriteLine(\\\"---\\\");\\nPrintValuesOfKeysWhere(dict, \\\".e\\\");\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"f.e \\netc. \\ni.e \\n--- \\ni.e \\n--- \\nfor example \\nmore precisely\\n\")), mdx(Note, {\n    mdxType: \"Note\"\n  }, \"Tulosteen j\\xE4rjestys voi vaihdella, koska hakemisto ei takaa avainten j\\xE4rjestyst\\xE4.\")), mdx(Exercise, {\n    title: '004 Book Dictionary',\n    mdxType: \"Exercise\"\n  }, mdx(\"p\", null, \"Teht\\xE4v\\xE4pohjassa on jo ennest\\xE4\\xE4n tutut luokat \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Book\"), \" ja \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Program\"), \". Toteuta luokkaan \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Program\"), \" seuraavat luokkametodit:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"public static void PrintValues(Dictionary< string, Book \", \">\", \" dictionary)\"), \", joka tulostaa kaikki hakemistossa olevat kirjat. K\\xE4yt\\xE4 kirjan \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"ToString\"), \"-metodia.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"public static void PrintValueIfNameContains(Dictionary< string, Book \", \">\", \" dictionary, string text)\"), \", j joka tulostaa vain ne kirjat, joiden nimi sis\\xE4lt\\xE4\\xE4 parametrina annetun merkkijonon. Voit l\\xF6yt\\xE4\\xE4 kirjan nimen \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"name\"), \"-ominaisuuden avulla.\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"Dictionary<string, Book> books = new Dictionary<string, Book>();\\nBook senseAndSensibility = new Book(\\\"Sense and Sensibility\\\", 1811, \\\"...\\\");\\nBook prideAndPrejudice = new Book(\\\"Pride and Prejudice\\\", 1813, \\\"....\\\");\\nbooks.Add(senseAndSensibility.name, senseAndSensibility);\\nbooks.Add(prideAndPrejudice.name, prideAndPrejudice);\\n\\nPrintValues(books);\\nConsole.WriteLine(\\\"-- -- -- --\\\");\\nPrintValueIfNameContains(books, \\\"prejud\\\");\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"Name: Sense and Sensibility (1811)\\nContent: ...\\nName: Pride and Prejudice (1813)\\nContent: ....\\n-- -- -- --\\nName: Pride and Prejudice (1813)\\nContent: ....\\n\")), mdx(Note, {\n    mdxType: \"Note\"\n  }, \"Tulosteen j\\xE4rjestys voi vaihdella, koska hakemisto ei takaa avainten j\\xE4rjestyst\\xE4.\"), mdx(Note, {\n    mdxType: \"Note\"\n  }, \"Haku on aakkoskoosta riippumaton!\")), mdx(Exercise, {\n    title: '005 I Owe You',\n    mdxType: \"Exercise\"\n  }, mdx(\"p\", null, \"Luo luokka \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"IOU\"), \", jolla on seuraavat metodit:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"konstruktori \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"public IOU()\"), \", joka luo uuden IOU-olion \"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"public void ChangeDebt(string toWhom, int amount)\"), \" tallentaa tiedon siit\\xE4, ett\\xE4 henkil\\xF6 on velkaa summan toiselle henkil\\xF6lle. Voit k\\xE4ytt\\xE4\\xE4 t\\xE4t\\xE4 metodia my\\xF6s velan pienent\\xE4miseen, mutta velan kokonaism\\xE4\\xE4r\\xE4 ei voi olla negatiivinen!\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"public int HowMuchDoIOweTo(string toWhom)\"), \" palauttaa summan, jonka parametrina annettu henkil\\xF6 on velkaa. Jos henkil\\xF6\\xE4 ei l\\xF6ydy, palautetaan 0.\")), mdx(\"p\", null, \"Luokkaa voidaan k\\xE4ytt\\xE4\\xE4 seuraavasti:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"IOU mattsIOU = new IOU();\\nmattsIOU.ChangeDebt(\\\"Arthur\\\", 51);\\nmattsIOU.ChangeDebt(\\\"Michael\\\", 30);\\n\\nConsole.WriteLine(mattsIOU.HowMuchDoIOweTo(\\\"Arthur\\\"));\\nConsole.WriteLine(mattsIOU.HowMuchDoIOweTo(\\\"Michael\\\"));\\nConsole.WriteLine(mattsIOU.HowMuchDoIOweTo(\\\"Heikki\\\"));\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"51\\n30\\n0\\n\")), mdx(Note, {\n    mdxType: \"Note\"\n  }, \"Jos uusi velka lis\\xE4t\\xE4\\xE4n, velka kasvaa tai pienenee. Ota t\\xE4m\\xE4 huomioon koodissasi. Lis\\xE4ksi kokonaisvelka ei voi olla negatiivinen!\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"IOU mattsIOU = new IOU();\\nmattsIOU.ChangeDebt(\\\"Arthur\\\", -10);\\n\\nConsole.WriteLine(mattsIOU.HowMuchDoIOweTo(\\\"Arthur\\\"));\\n\\nmattsIOU.ChangeDebt(\\\"Arthur\\\", 51);\\nmattsIOU.ChangeDebt(\\\"Arthur\\\", 30);\\n\\nConsole.WriteLine(mattsIOU.HowMuchDoIOweTo(\\\"Arthur\\\"));\\n\\nmattsIOU.ChangeDebt(\\\"Arthur\\\", -30);\\n\\nConsole.WriteLine(mattsIOU.HowMuchDoIOweTo(\\\"Arthur\\\"));\\n\\nmattsIOU.ChangeDebt(\\\"Arthur\\\", -80);\\n\\nConsole.WriteLine(mattsIOU.HowMuchDoIOweTo(\\\"Arthur\\\"));\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"0\\n81\\n51\\n0\\n\"))));\n}\n;\nMDXContent.isMDXComponent = true;","tableOfContents":{"items":[{"items":[{"url":"#hakemiston-avaimet-vastaa-enintään-yhtä-arvoa","title":"Hakemiston avaimet vastaa enintään yhtä arvoa"},{"url":"#viittaustyyppinen-muuttuja-hakemiston-arvona","title":"Viittaustyyppinen muuttuja hakemiston arvona"},{"url":"#milloin-hakemistoja-kannattaa-käyttää","title":"Milloin hakemistoja kannattaa käyttää?"},{"url":"#hakemisto-instanssimuuttujana","title":"Hakemisto instanssimuuttujana"},{"url":"#hakemiston-avainten-läpikäynti","title":"Hakemiston avainten läpikäynti"},{"url":"#hakemiston-arvojen-läpikäynti","title":"Hakemiston arvojen läpikäynti"}]},{"url":"#tehtävät","title":"Tehtävät"}]},"frontmatter":{"title":"Hakemistot"}}},"pageContext":{"id":"044e3bf5-d928-5fdb-b571-e18f5b80be74"}},
    "staticQueryHashes": ["1885717130","1950529541","2744905544","3020054368"]}