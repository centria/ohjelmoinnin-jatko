{
    "componentChunkName": "component---src-templates-docs-js",
    "path": "/osa08/osa08-2",
    "result": {"data":{"mdx":{"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Olioiden samankaltaisuus\",\n  \"nav_order\": 82,\n  \"hidden\": false\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar Exercise = makeShortcode(\"Exercise\");\nvar Note = makeShortcode(\"Note\");\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Kerrataan viel\\xE4 \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Equals\"), \"-metodi, jolla olioita vertaillaan, ja tutustutaan \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"GetHashCode\"), \"-metodiin, jolla tehd\\xE4\\xE4n likim\\xE4\\xE4r\\xE4isi\\xE4 vertailuja.\"), mdx(\"h2\", {\n    \"id\": \"metodi-yhdenvertaisuuden-tarkasteluun---equals\"\n  }, \"Metodi yhdenvertaisuuden tarkasteluun - \\\"Equals\\\"\"), mdx(\"p\", null, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://learn.microsoft.com/en-us/dotnet/api/system.object.Equals?view=net-6.0\"\n  }, mdx(\"strong\", {\n    parentName: \"a\"\n  }, \"Equals metodi\")), \" oletusarvoisesti tarkastaa, onko parametrina annetun olion viite sama kuin sen johon sit\\xE4 verrataan. Toisinsanoen, oletusk\\xE4ytt\\xE4ytyminen tarkastaa, ovatko kaksi oliota samat. Jos viite on sama, metodi palauttaa true, muuten false.\"), mdx(\"p\", null, \"T\\xE4t\\xE4 voidaan havainnollistaa seuraavalla esimerkill\\xE4. Book-luokalla ei ole omaa toteutusta Equals-metodille, joten se turvautuu C#:n tarjoamaan oletustoteutukseen.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"Book bookObject = new Book(\\\"Book object\\\", 2000, \\\"...\\\");\\nBook anotherBookObject = bookObject;\\n\\nif (bookObject.Equals(anotherBookObject))\\n{\\n  Console.WriteLine(\\\"The books were the same\\\");\\n}\\nelse\\n{\\n  Console.WriteLine(\\\"The books weren't the same\\\");\\n}\\n\\n// nyt luodaan uusi olio, jolla on samat sis\\xE4ll\\xF6t, mutta joka on silti oma olionsa\\nanotherBookObject = new Book(\\\"Book object\\\", 2000, \\\"...\\\");\\n\\nif (bookObject.Equals(anotherBookObject))\\n{\\n  Console.WriteLine(\\\"The books were the same\\\");\\n}\\nelse\\n{\\n  Console.WriteLine(\\\"The books weren't the same\\\");\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"The books were the same\\nThe books weren't the same\\n\")), mdx(\"p\", null, \"Kirjojen sis\\xE4inen rakenne (eli niiden olioiden instanssimuuttujien arvot) on sama, mutta vain ensimm\\xE4inen vertailu tulostaa \\\"The books were the same\\\". T\\xE4m\\xE4 johtuu siit\\xE4, ett\\xE4 viitteet ovat ensimm\\xE4isess\\xE4 tapauksessa samat, eli olio vertaa itse\\xE4\\xE4n itseens\\xE4. Toisessa vertailussa on kyse kahdesta eri oliosta, vaikka muuttujien arvot olisivatkin samat.\"), mdx(\"p\", null, \"Jos haluamme vertailla omia luokkiamme Equals-metodilla, se t\\xE4ytyy m\\xE4\\xE4ritell\\xE4 luokan sis\\xE4lle. Luotu metodi ottaa parametrina Object-tyyppisen viitteen, joka voi olla mik\\xE4 tahansa olio. Vertailussa ensin katsotaan viitteet. T\\xE4m\\xE4n j\\xE4lkeen tarkastetaan parametrina annetun olion tyyppi instanceof-operaatiolla - jos olion tyyppi ei vastaa omaa luokkaa, olio ei voi olla sama. Luodaan t\\xE4m\\xE4n j\\xE4lkeen versio oliosta, joka on samaa tyyppi\\xE4 kuin oma luokkamme, jonka j\\xE4lkeen vertaillaan olioiden muuttujia kesken\\xE4\\xE4n.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"public override bool Equals(object compared)\\n{\\n  // jos oliot ovat samassa sijainnissa, ne ovat samat\\n  if (this == compared)\\n  {\\n    return true;\\n  }\\n\\n  // jos verrattava olio on null tai ei ole tyyppi\\xE4 Book, oliot eiv\\xE4t ole samat\\n  if ((compared == null) || !this.GetType().Equals(compared.GetType()))\\n  {\\n    return false;\\n  }\\n  else\\n  {\\n    // muunnetaan olio Book-tyyppiseksi\\n    Book comparedBook = (Book)compared;\\n\\n    // jos olioiden muuttujien arvot ovat samat, oliot ovat samat\\n    return this.name == comparedBook.name && this.published == comparedBook.published && this.content == comparedBook.content;\\n  }\\n}\\n\")), mdx(\"p\", null, \"Alla Book-luokka kokonaisuudessaan.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"namespace Exercise001\\n{\\n  public class Book\\n  {\\n    public string name { get; set; }\\n    public string content { get; set; }\\n    public int published { get; set; }\\n\\n    public Book(string name, int published, string content)\\n    {\\n      this.name = name;\\n      this.published = published;\\n      this.content = content;\\n    }\\n\\n    public override string Tostring()\\n    {\\n      return \\\"Name: \\\" + this.name + \\\" (\\\" + this.published + \\\")\\\\n\\\"\\n          + \\\"Content: \\\" + this.content;\\n    }\\n\\n    public override bool Equals(object compared)\\n    {\\n      if (this == compared)\\n      {\\n        return true;\\n      }\\n      if ((compared == null) || !this.GetType().Equals(compared.GetType()))\\n      {\\n        return false;\\n      }\\n      else\\n      {\\n        Book comparedBook = (Book)compared;\\n        return this.name == comparedBook.name && \\n        this.published == comparedBook.published && \\n        this.content == comparedBook.content;\\n      }\\n    }\\n  }\\n}\\n\")), mdx(\"p\", null, \"Nyt kirjojen vertailu palauttaa \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"true\"), \" jos kirjojen instanssimuuttujat ovat samat.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"Book bookObject = new Book(\\\"Book object\\\", 2000, \\\"...\\\");\\nBook anotherBookObject = new Book(\\\"Book object\\\", 2000, \\\"...\\\");\\n\\nif (bookObject.Equals(anotherBookObject))\\n{\\n  Console.WriteLine(\\\"The books were the same\\\");\\n}\\nelse\\n{\\n  Console.WriteLine(\\\"The books weren't the same\\\");\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"Book.cs(3,16): warning CS0659: 'Book' overrides Object.Equals(object o) but does not override Object.GetHashCode() [/mnt/c/Users/HeikkiHei/Documents/coding-exercises/Exercise001/Exercise001.csproj]\\n\\nThe books were the same\\n\")), mdx(\"p\", null, \"Saamme my\\xF6s hyvin tutun varoituksen. Vihdoin t\\xE4ss\\xE4 osiossa teemme jotain asian eteen.\"), mdx(\"p\", null, \"My\\xF6s \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"List\"), \" k\\xE4ytt\\xE4\\xE4 sis\\xE4isesti Equals-metodia. Jos emme m\\xE4\\xE4rittele Equals-metodia omiin olioihimme, Listin sis\\xE4inen toteutus ei toimi oikein. Kokeile alla olevaa koodia kahdella Book-luokalla, joista toisessa on m\\xE4\\xE4ritelty Equals-metodi ja toisessa ei, niin huomaat eron.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"List<Book> books = new List<Book>();\\nBook bookObject = new Book(\\\"Book Object\\\", 2000, \\\"...\\\");\\nbooks.Add(bookObject);\\n\\nif (books.Contains(bookObject))\\n{\\n  Console.WriteLine(\\\"Book Object was found.\\\");\\n}\\n\\nbookObject = new Book(\\\"Book Object\\\", 2000, \\\"...\\\");\\n\\nif (!books.Contains(bookObject))\\n{\\n  Console.WriteLine(\\\"Book Object was not found.\\\");\\n}\\n\")), mdx(\"p\", null, \"T\\xE4m\\xE4 riippuvuus oletustoteutuksista, kuten Equals, on itseasiassa syy sille, miksi C# vaatii, ett\\xE4 Listiin ja Dictionaryyn lis\\xE4tt\\xE4v\\xE4t muuttujat ovat viittausmuuttujia. Jokaisen viittausmuuttujan mukana tulee oletustoteutuksia, kuten Equals, jolloin Listin sis\\xE4ist\\xE4 toteutusta ei tarvitse muuttaa, kun lis\\xE4t\\xE4\\xE4n eri tyyppisi\\xE4 muuttujia.\"), mdx(\"h2\", {\n    \"id\": \"vertailun-likimääräisyys-hakemistoissa\"\n  }, \"Vertailun likim\\xE4\\xE4r\\xE4isyys hakemistoissa\"), mdx(\"p\", null, \"Equals-metodin lis\\xE4ksi, metodia \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"GetHashCode\"), \" voidaan k\\xE4ytt\\xE4\\xE4 samankaltaisuuden likim\\xE4\\xE4r\\xE4iseen vertailuun. Metodi luo oliosta \\\"hash-koodin\\\", eli numeron, joka kertoo hieman olioiden sis\\xE4ll\\xF6st\\xE4. Jos kahdella oliolla on sama hash-arvo, ne voivat olla samat. Toisaalta, jos kahdella oliolla on eri hash-arvot, ne eiv\\xE4t voi olla samat.\"), mdx(\"p\", null, \"Hash-koodeja k\\xE4ytet\\xE4\\xE4n esimerkiksi hakemistoissa. Hakemiston sis\\xE4inen rakenne perustuu siihen, ett\\xE4 avain-arvo -parit tallennetaan taulukkoon joka perustuu avainten hash-arvoihin. Jokainen taulukon indeksi osoittaa listaan. Hash-arvo m\\xE4\\xE4ritt\\xE4\\xE4 indeksin, jolloin listaan osoittava indeksi on tiedossa. T\\xE4m\\xE4n j\\xE4lkeen listaa k\\xE4yd\\xE4\\xE4n l\\xE4pi, kunnes avain l\\xF6ytyy (vertailu tehd\\xE4\\xE4n Equals-metodilla). T\\xE4ll\\xE4 tavalla hakemistoa ei tarvitse k\\xE4yd\\xE4 l\\xE4pi kokonaan, vaan vain pieni osa avaimista.\"), mdx(\"p\", null, \"T\\xE4h\\xE4n menness\\xE4 olemme k\\xE4ytt\\xE4neet vain merkkijono-olioita hakemiston avaimina, joilla on valmiiksi toteutettu GetHashCode-metodi. Luodaan esimerkki, jossa n\\xE4in ei ole. Jatkamme kirjoilla ja pid\\xE4mme kirjaa lainassa olevista kirjoista. Kirjat pidet\\xE4\\xE4n hakemistossa, jonka avain on kirja ja arvo on merkkijono, joka kertoo lainaajan nimen.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"Dictionary<Book, string> borrowers = new Dictionary<Book, string>();\\n\\nBook bookObject = new Book(\\\"Book Object\\\", 2000, \\\"...\\\");\\nborrowers.Add(bookObject, \\\"Pekka\\\");\\nborrowers.Add(new Book(\\\"Test Driven Development\\\", 1999, \\\"...\\\"), \\\"Arto\\\");\\n\\nConsole.WriteLine(borrowers[bookObject]);\\nConsole.WriteLine(borrowers[new Book(\\\"Book Object\\\", 2000, \\\"...\\\")]);\\nConsole.WriteLine(borrowers[new Book(\\\"Test Driven Development\\\", 1999, \\\"...\\\")]);\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"Pekka\\nUnhandled exception. System.Collections.Generic.KeyNotFoundException: The given key 'Name: Book Object (2000) \\n[. . .]\\n\")), mdx(\"p\", null, \"Saamme virheen, kun toisessa Console.WriteLine:ssa luotu olio ei vastaa mit\\xE4\\xE4n avainta (eik\\xE4 kolmannessakaan, mutta ohjelma lopettaa ensimm\\xE4iseen virheeseen).\"), mdx(\"p\", null, \"L\\xF6yd\\xE4mme lainaajan kun etsimme samaa oliota, joka on lis\\xE4tty hakemistoon hakemiston Add metodilla. Kuitenkin kun haemme t\\xE4sm\\xE4lleen samalaista kirjaa mutta eri oliolla, lainaajaa ei l\\xF6ydy, ja saamme virheilmoituksen sen sijaan. Syy t\\xE4h\\xE4n on Object-luokan oletustoteutus GetHashCode-metodille. Oletustoteutus luo hash-arvon olion viitteen perusteella, joten kirjat, joilla on sama sis\\xE4lt\\xF6, mutta jotka ovat eri olioita, saavat eri hash-arvot. T\\xE4m\\xE4n seurauksena olioita ei l\\xF6ydy hakemistosta, vaikka niiden sis\\xE4lt\\xF6 olisi sama.\"), mdx(\"p\", null, \"Jotta hakemisto toimisi halutulla tavalla, eli palauttaisi lainaajan kun sille annetaan olio, jolla on sama sis\\xE4lt\\xF6 kuin avaimella, t\\xE4ytyy luokkaa Book muokata. Luokan t\\xE4ytyy ylikirjoittaa GetHashCode-metodi sen Equals-metodin lis\\xE4ksi. Metodi t\\xE4ytyy ylikirjoittaa siten, ett\\xE4 se palauttaa saman hash-arvon kaikille olioille, joilla on sama sis\\xE4lt\\xF6. Lis\\xE4ksi oliot joilla on eri sis\\xE4lt\\xF6 voivat saada saman tuloksen GetHashCOde-metodista. Kuitenkin hakemiston tehokkuuden kannalta on t\\xE4rke\\xE4\\xE4 ett\\xE4 erisis\\xE4lt\\xF6iset kirjat saavat saman hash-arvon mahdollisimman harvoin.\"), mdx(\"p\", null, \"Olemme aiemmin k\\xE4ytt\\xE4neen merkkijono-olioita hakemiston avaimina, joten voimme p\\xE4\\xE4tell\\xE4, ett\\xE4 merkkijono-luokalla on hyvin toimiva GetHashCode-metodi. Siirr\\xE4mme laskennan merkkijono-oliolle.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"public override int GetHashCode()\\n{\\n  return this.name.GetHashCode();\\n}\\n\")), mdx(\"p\", null, \"Yll\\xE4 oleva esimerkki on melko hyv\\xE4. Kuitenkin, jos kirjan nimi on null, saamme NullReferenceException virheen. Korjataan t\\xE4m\\xE4 m\\xE4\\xE4rittelem\\xE4ll\\xE4 ehto: jos nimi on null, palautetaan julkaisuvuosi hash-arvona.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"public override int GetHashCode()\\n{\\n  if (this.name == null)\\n  {\\n    return this.published;\\n  }\\n  return this.name.GetHashCode();\\n}\\n\")), mdx(\"p\", null, \"Nyt, kaikki kirjat joilla on sama nimi, ovat samassa ryhm\\xE4ss\\xE4. Parannetaan sit\\xE4 viel\\xE4 niin, ett\\xE4 julkaisuvuosi otetaan my\\xF6s huomioon hash-arvoa laskettaessa kirjan nimen lis\\xE4ksi.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"public override int GetHashCode()\\n{\\n  if (this.name == null)\\n  {\\n    return this.published;\\n  }\\n  return this.published + this.name.GetHashCode();\\n}\\n\")), mdx(\"p\", null, \"Nyt on mahdollista k\\xE4ytt\\xE4\\xE4 kirjaa hakemiston avaimena. T\\xE4ll\\xF6in aiemmin esiintynyt ongelma ratkeaa ja kirjan lainaaja l\\xF6ytyy:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"Dictionary<Book, string> borrowers = new Dictionary<Book, string>();\\n\\nBook bookObject = new Book(\\\"Book Object\\\", 2000, \\\"...\\\");\\nborrowers.Add(bookObject, \\\"Pekka\\\");\\nborrowers.Add(new Book(\\\"Test Driven Development\\\", 1999, \\\"...\\\"), \\\"Arto\\\");\\n\\nConsole.WriteLine(borrowers[bookObject]);\\nConsole.WriteLine(borrowers[new Book(\\\"Book Object\\\", 2000, \\\"...\\\")]);\\nConsole.WriteLine(borrowers[new Book(\\\"Test Driven Development\\\", 1999, \\\"...\\\")]);\\n\")), mdx(\"p\", null, \"Prints\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"Pekka\\nPekka\\nArto\\n\")), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Kehitet\\xE4\\xE4n ideaa viel\\xE4 kerran:\"), \" jotta luokkaa voidaan k\\xE4ytt\\xE4\\xE4 hakemiston avaimena, t\\xE4ytyy luokalle m\\xE4\\xE4ritell\\xE4:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Equals-metodi, jotta kaikki samat tai likim\\xE4\\xE4r\\xE4isesti samat oliot aiheuttavat vertailussa true ja kaikki muut false\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"GetHashCode-metodi, jotta mahdollisimman harvalla oliolla on sama hash-arvo\")), mdx(\"h1\", {\n    \"id\": \"tehtävät\"\n  }, \"Teht\\xE4v\\xE4t\"), mdx(Exercise, {\n    title: '006 Same Date',\n    mdxType: \"Exercise\"\n  }, mdx(\"p\", null, \"Teht\\xE4v\\xE4pohjassa on luokka \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"SimpleDate\"), \", joka m\\xE4\\xE4rittelee p\\xE4iv\\xE4m\\xE4\\xE4r\\xE4n p\\xE4iv\\xE4n, kuukauden ja vuoden perusteella. T\\xE4ss\\xE4 teht\\xE4v\\xE4ss\\xE4 laajennat SimpleDate-luokkaa \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Equals\"), \"-metodilla, joka kertoo ovatko p\\xE4iv\\xE4m\\xE4\\xE4r\\xE4t t\\xE4sm\\xE4lleen samat.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Luo metodi \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"public override bool Equals(object compared)\"), \" SimpleDate-luokalle, joka palauttaa true, jos metodille parametrina annettu olio on samanlainen kuin metodia kutsuva olio. Muuten metodi palauttaa false.\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Luo metodi \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"public override int GetHashCode()\"), \" SimpleDate-luokalle, joka laskee olion hash-arvon. Toteuta laskenta siten, ett\\xE4 vuosien 1900 ja 2100 v\\xE4lill\\xE4 on mahdollisimman v\\xE4h\\xE4n samanlaisia hash-arvoja.\"))), mdx(\"p\", null, \"Equals-metodin tulisi toimia seuraavasti:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"SimpleDate d = new SimpleDate(1, 2, 2000);\\nConsole.WriteLine(d.Equals(\\\"heh\\\"));\\nConsole.WriteLine(d.Equals(new SimpleDate(5, 2, 2012)));\\nConsole.WriteLine(d.Equals(new SimpleDate(1, 2, 2000)));\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"false\\nfalse\\ntrue\\n\"))), mdx(Exercise, {\n    title: '007 Vehicle Registry',\n    mdxType: \"Exercise\"\n  }, mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Osa 1\")), mdx(\"p\", null, \"Eurooppalaisissa rekisterikilviss\\xE4 on kaksi osaa, kaksikirjaiminen maatunnus ja kansallisesti yksil\\xF6llinen rekisterinumero. Rekisterinumero koostuu numeroista ja kirjaimista. Rekisterikilpi\\xE4 edustaa seuraava luokka:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"public class LicensePlate\\n{\\n  private string liNumber;\\n  private string country;\\n\\n  public LicensePlate(string country, string liNumber)\\n  {\\n    this.liNumber = liNumber;\\n    this.country = country;\\n  }\\n\\n\\n  public override string ToString()\\n  {\\n    return country + \\\" \\\" + liNumber;\\n  }\\n}\\n\")), mdx(\"p\", null, \"Haluamme ett\\xE4 voimme tallentaa rekisterikilpi\\xE4 esimerkiksi listaan ja k\\xE4ytt\\xE4\\xE4 niit\\xE4 avaimina hakemistossa. T\\xE4m\\xE4 tarkoittaa, ett\\xE4 \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Equals\"), \"- ja \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"GetHashCode\"), \"-metodit t\\xE4ytyy ylikirjoittaa, tai ne eiv\\xE4t toimi halutulla tavalla. Toteuta \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Equals\"), \"- ja \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"GetHashCode\"), \"-metodit \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"LicensePlate\"), \"-luokalle.\"), mdx(\"p\", null, \"Esimerkkiohjelma:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"LicensePlate li1 = new LicensePlate(\\\"FI\\\", \\\"ABC-123\\\");\\nLicensePlate li2 = new LicensePlate(\\\"FI\\\", \\\"UXE-465\\\");\\nLicensePlate li3 = new LicensePlate(\\\"D\\\", \\\"B WQ-431\\\");\\n\\nList<LicensePlate> finnishPlates = new List<LicensePlate>();\\nfinnishPlates.Add(li1);\\nfinnishPlates.Add(li2);\\n\\nLicensePlate newLi = new LicensePlate(\\\"FI\\\", \\\"ABC-123\\\");\\nif (!finnishPlates.Contains(newLi))\\n{\\n  finnishPlates.Add(newLi);\\n}\\nConsole.WriteLine(\\\"Finnish: \\\");\\nforeach (LicensePlate plate in finnishPlates)\\n{\\n  Console.WriteLine(plate);\\n}\\n\\nDictionary<LicensePlate, string> owners = new Dictionary<LicensePlate, string>();\\nowners.Add(li1, \\\"Arto\\\");\\nowners.Add(li3, \\\"J\\xFCrgen\\\");\\n\\nConsole.WriteLine(\\\"Owners:\\\");\\nConsole.WriteLine(owners[new LicensePlate(\\\"FI\\\", \\\"ABC-123\\\")]);\\nConsole.WriteLine(owners[new LicensePlate(\\\"D\\\", \\\"B WQ-431\\\")]);\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"Finnish: \\nFI ABC-123\\nFI UXE-465\\nOwners:\\nArto\\nJ\\xFCrgen\\n\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Osa 2\")), mdx(\"p\", null, \"Luo luokka \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"VehicleRegistry\"), \", jolla on seuraavat metodit:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"public bool Add(LicensePlate licensePlate, string owner)\"), \" sijoittaa parametrina saadun rekisterikilven ja omistajan rekisteriin. Jos rekisterikilpi on jo rekisteriss\\xE4, metodi ei tee mit\\xE4\\xE4n ja palauttaa \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"false\"), \". Jos rekisterikilpi ei ole rekisteriss\\xE4, metodi lis\\xE4\\xE4 sen rekisteriin ja palauttaa \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"true\"), \".\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"public string Get(LicensePlate licensePlate)\"), \" palauttaa rekisteriss\\xE4 olevan rekisterikilven omistajan. Jos rekisterikilpe\\xE4 ei ole rekisteriss\\xE4, palauttaa virheilmoituksen (m\\xE4\\xE4rit\\xE4 sopiva virheviesti).\"))), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"public bool Remove(LicensePlate licensePlate)\"), \" poistaa rekisterikilven rekisterist\\xE4. Palauttaa \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"true\"), \" jos rekisterikilpi l\\xF6ytyi rekisterist\\xE4 ja poistettiin, muuten \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"false\"), \".\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"public void PrintLicensePlates()\"), \" tulostaa kaikki rekisterikilvet rekisteriss\\xE4.\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"public void PrintOwners()\"), \" tulostaa kaikki rekisteriss\\xE4 olevien autojen omistajat. Jokaisen omistajan tulee tulostua vain kerran, vaikka h\\xE4n omistaisi useamman auton.\"))), mdx(\"p\", null, \"Nyt ohjelma toimii seuraavasti:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"LicensePlate li1 = new LicensePlate(\\\"FI\\\", \\\"ABC-123\\\");\\nLicensePlate li2 = new LicensePlate(\\\"FI\\\", \\\"UXE-465\\\");\\nLicensePlate li3 = new LicensePlate(\\\"D\\\", \\\"B WQ-431\\\");\\nLicensePlate li4 = new LicensePlate(\\\"D\\\", \\\"B WQ-432\\\");\\nLicensePlate li5 = new LicensePlate(\\\"D\\\", \\\"B WQ-433\\\");\\n\\nVehicleRegistry register = new VehicleRegistry();\\n\\nregister.Add(li1, \\\"Arto\\\");\\nregister.Add(li2, \\\"Arto\\\");\\nregister.Add(li3, \\\"J\\xFCrgen\\\");\\nregister.Add(li4, \\\"J\\xFCrgen\\\");\\nregister.Add(li5, \\\"J\\xFCrgen\\\");\\n\\nConsole.WriteLine(\\\"Plates:\\\");\\nregister.PrintLicensePlates();\\n\\nConsole.WriteLine(\\\"Owners:\\\");\\nregister.PrintOwners();\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"Plates:\\nFI ABC-123\\nFI UXE-465\\nD B WQ-431\\nD B WQ-432\\nD B WQ-433\\nOwners:\\nArto\\nJ\\xFCrgen\\n\")), mdx(Note, {\n    mdxType: \"Note\"\n  }, \"Metodissa PrintOwners voit luoda listan, jolla muistat jo tulostetut omistajat. Jos omistaja ei ole listalla, tulostetaan h\\xE4nen nimens\\xE4 ja lis\\xE4t\\xE4\\xE4n h\\xE4net listaan -- jos omistaja on listalla, h\\xE4nen nime\\xE4\\xE4n ei tulosteta.\")));\n}\n;\nMDXContent.isMDXComponent = true;","tableOfContents":{"items":[{"items":[{"url":"#metodi-yhdenvertaisuuden-tarkasteluun---equals","title":"Metodi yhdenvertaisuuden tarkasteluun - \"Equals\""},{"url":"#vertailun-likimääräisyys-hakemistoissa","title":"Vertailun likimääräisyys hakemistoissa"}]},{"url":"#tehtävät","title":"Tehtävät"}]},"frontmatter":{"title":"Olioiden samankaltaisuus"}}},"pageContext":{"id":"624d0762-7a76-5c61-9943-c01494a812da"}},
    "staticQueryHashes": ["1885717130","1950529541","2744905544","3020054368"]}