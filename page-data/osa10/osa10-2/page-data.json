{
    "componentChunkName": "component---src-templates-docs-js",
    "path": "/osa10/osa10-2",
    "result": {"data":{"mdx":{"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Merkkijonojen käsittely\",\n  \"nav_order\": 102,\n  \"hidden\": false\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar Note = makeShortcode(\"Note\");\nvar Exercise = makeShortcode(\"Exercise\");\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"stringbuilder-ja-säännölliset-lausekkeet-regex\"\n  }, \"StringBuilder ja S\\xE4\\xE4nn\\xF6lliset lausekkeet (RegEx)\"), mdx(\"p\", null, \"Tarkastellaan nyt muutamia hy\\xF6dyllisi\\xE4 ohjelmointitekniikoita ja luokkia.\"), mdx(\"h2\", {\n    \"id\": \"stringbuilder\"\n  }, \"StringBuilder\"), mdx(\"p\", null, \"Katsotaan seuraavaa ohjelmaa\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"string numbers = \\\"\\\";\\nfor (int i = 1; i < 5; i++)\\n{\\n  numbers = numbers + i;\\n}\\nConsole.WriteLine(numbers);\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"1234\\n\")), mdx(\"p\", null, \"Ohjelman rakenne on suoraviivainen. Luodaan merkkijono, joka sis\\xE4lt\\xE4\\xE4 numeron 1234, ja tulostetaan merkkijono.\"), mdx(\"p\", null, \"Ohjelma toimii, mutta siin\\xE4 on pieni k\\xE4ytt\\xE4j\\xE4lle n\\xE4kym\\xE4t\\xF6n ongelma. Kutsu \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"numbers + i\"), \" luo itse asiassa uuden merkkijonon. Tutkitaan ohjelmaa rivi rivilt\\xE4 toistok\\xE4sky lohkot purettuna.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"string numbers = \\\"\\\"; // luodaan uusi merkkijono: \\\"\\\"\\nint i = 1;\\nnumbers = numbers + i; // luodaan uusi merkkijono: \\\"1\\\"\\ni++;\\nnumbers = numbers + i; // luodaan uusi merkkijono: \\\"12\\\"\\ni++;\\nnumbers = numbers + i; // luodaan uusi merkkijono: \\\"123\\\"\\ni++;\\nnumbers = numbers + i; // luodaan uusi merkkijono: \\\"1234\\\"\\ni++;\\n\\nConsole.WriteLine(numbers); // tulostetaan merkkijono\\n\")), mdx(\"p\", null, \"Edellisess\\xE4 esimerkiss\\xE4 luotiin yhteens\\xE4 viisi merkkijonoa.\"), mdx(\"p\", null, \"Tarkastellaan samaa ohjelmaa, jossa jokaisen numeron j\\xE4lkeen lis\\xE4t\\xE4\\xE4n uusi rivi.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"string numbers = \\\"\\\";\\nfor (int i = 1; i < 5; i++)\\n{\\n  numbers = numbers + i + \\\"\\\\n\\\";\\n}\\nConsole.WriteLine(numbers);\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"1\\n2\\n3\\n4\\n\")), mdx(\"p\", null, \"Jokainen \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"+-operaatio\"), \" muodostaa uuden merkkijonon. Rivinumeron + i + \\\"\\\\n\\\"; kohdalla ensin luodaan merkkijono, jonka j\\xE4lkeen luodaan uusi merkkijono, johon liitet\\xE4\\xE4n uusi rivi edellisen merkkijonon per\\xE4\\xE4n. Kirjoitetaan t\\xE4m\\xE4kin auki.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"string numbers = \\\"\\\"; // luodaan uusi merkkijono: \\\"\\\"\\nint i = 1;\\n// ensin luodaan merkkijono \\\"1\\\" ja sitten merkkijono \\\"1\\\\n\\\"\\nnumbers = numbers + i + \\\"\\\\n\\\";\\ni++;\\n// ensin luodaan merkkijono \\\"1\\\\n2\\\" ja sitten merkkijono \\\"1\\\\n2\\\\n\\\"\\nnumbers = numbers + i + \\\"\\\\n\\\"\\ni++;\\n// ensin luodaan merkkijono \\\"1\\\\n2\\\\n3\\\" ja sitten merkkijono \\\"1\\\\n2\\\\n3\\\\n\\\"\\nnumbers = numbers + i + \\\"\\\\n\\\"\\ni++;\\n// ensin luodaan merkkijono \\\"1\\\\n2\\\\n3\\\\n4\\\" ja sitten merkkijono \\\"1\\\\n2\\\\n3\\\\n4\\\\n\\\"\\nnumbers = numbers + i + \\\"\\\\n\\\"\\ni++;\\n\\nConsole.WriteLine(numbers); // tulostetaan merkkijono\\n\")), mdx(\"p\", null, \"Edellisess\\xE4 esimerkiss\\xE4 luotiin yhteens\\xE4 yhdeks\\xE4n merkkijonoa.\"), mdx(\"p\", null, \"Merkkijonon luominen - vaikka pieness\\xE4 mittakaavassa huomaamaton - ei ole nopea operaatio. Muistista varataan tila jokaiselle merkkijonolle, johon merkkijono sitten sijoitetaan. Jos merkkijonoa tarvitaan vain osana suuremman merkkijonon luomista, suorituskyky\\xE4 kannattaa parantaa.\"), mdx(\"p\", null, \"C#:n valmis metodi \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"StringBuilder\"), \" luokasta \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"System.Text\"), \" tarjoaa tavan yhdist\\xE4\\xE4 merkkijonoja ilman, ett\\xE4 niit\\xE4 tarvitsee luoda. Luodaan uusi StringBuilder-olio \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"new StringBuilder()\"), \" kutsulla, ja sis\\xE4lt\\xF6\\xE4 lis\\xE4t\\xE4\\xE4n olioon k\\xE4ytt\\xE4m\\xE4ll\\xE4 ylikuormitettua \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Append\"), \"-metodia, eli sille on eri versioita eri tyyppisille muuttujille. Lopuksi StringBuilder-olio tarjoaa merkkijonon ToString-metodilla.\"), mdx(\"p\", null, \"Alla olevassa esimerkiss\\xE4 luodaan vain yksi merkkijono.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"namespace Exercise001\\n{\\n  using System;\\n  using System.Text;\\n  class Program\\n  {\\n    static void Main(string[] args)\\n    {\\n      StringBuilder numbers = new StringBuilder();\\n      for (int i = 1; i < 5; i++)\\n      {\\n        numbers.Append(i);\\n      }\\n      Console.WriteLine(numbers.ToString());\\n    }\\n  }\\n}\\n\")), mdx(\"p\", null, \"Metodin StringBuilder k\\xE4ytt\\xE4minen on suorituskyvyn kannalta parempi vaihtoehto kuin merkkijonojen yhdist\\xE4minen + operaattorilla.\"), mdx(Note, {\n    mdxType: \"Note\"\n  }, \"Tarvitsemme using System.Text; -lauseen, jotta StringBuilder toimisi.\"), mdx(\"h2\", {\n    \"id\": \"säännölliset-lausekkeet-regex\"\n  }, \"S\\xE4\\xE4nn\\xF6lliset lausekkeet, Regex\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"S\\xE4\\xE4nn\\xF6llinen lauseke\"), \" (englanniksi \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"regular expression\"), \") m\\xE4\\xE4rittelee merkkijoukon tiiviiss\\xE4 muodossa. S\\xE4\\xE4nn\\xF6llisi\\xE4 lausekkeita k\\xE4ytet\\xE4\\xE4n muun muassa merkkijonojen oikeellisuuden tarkistamiseen. Voimme arvioida, onko merkkijono halutussa muodossa s\\xE4\\xE4nn\\xF6llisell\\xE4 lausekkeella, joka m\\xE4\\xE4rittelee halutut merkkijonot.\"), mdx(\"p\", null, \"Tarkastellaan ongelmaa, jossa haluamme tarkistaa, onko k\\xE4ytt\\xE4j\\xE4n sy\\xF6tt\\xE4m\\xE4 merkkijono oikeassa muodossa. Opiskelijanumero (omassa alma materissani, Helsingin yliopistossa, josta t\\xE4m\\xE4 kurssimateriaalikin on per\\xE4isin) alkaa \\\"01\\\":ll\\xE4 ja jatkuu tarkalleen 7 numerolla v\\xE4lill\\xE4 0\\u20139.\"), mdx(\"p\", null, \"Voimme tarkistaa opiskelijanumeron muodon esimerkiksi k\\xE4ym\\xE4ll\\xE4 l\\xE4pi merkkijonon merkkej\\xE4 string\", \"[\", \"index\", \"]\", \" -metodilla. Toinen tapa olisi tarkistaa, ett\\xE4 ensimm\\xE4inen merkki on \\\"0\\\" ja kutsua Convert.ToInt32 -metodia muuttaaksesi merkkijonon numeroksi. Voit sitten tarkistaa, ett\\xE4 Convert.ToInt32 -metodin palauttama numero on pienempi kuin 20000000.\"), mdx(\"p\", null, \"Oikeellisuuden tarkistaminen s\\xE4\\xE4nn\\xF6llisell\\xE4 lausekkeella tehd\\xE4\\xE4n ensin m\\xE4\\xE4rittelem\\xE4ll\\xE4 sopiva s\\xE4\\xE4nn\\xF6llinen lauseke. Voimme sitten k\\xE4ytt\\xE4\\xE4 Regex-luokan \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"IsMatch\"), \"-metodia joka tarkistaa, sis\\xE4lt\\xE4\\xE4k\\xF6 annettu merkkijono s\\xE4\\xE4nn\\xF6llisen lausekkeen joka on annettu Regex-luokan konstruktorin parametrina. Opiskelijanumeron kohdalla sopiva s\\xE4\\xE4nn\\xF6llinen lauseke on \\\"^01\", \"[\", \"0-9\", \"]\", \"{7\", \"}\", \"$\\\", ja k\\xE4ytt\\xE4j\\xE4n sy\\xF6tt\\xE4m\\xE4n opiskelijanumeron tarkistaminen tehd\\xE4\\xE4n seuraavasti:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"namespace Exercise001\\n{\\n  using System;\\n  using System.Text.RegularExpressions;\\n\\n  class Program\\n  {\\n    static void Main(string[] args)\\n    {\\n      // Alkaa 01\\n      // Sis\\xE4lt\\xE4\\xE4 vain numeroita 0-9\\n      // Tasan 7 numeroa\\n      // Merkkijono loppuu t\\xE4h\\xE4n\\n      Regex regex = new Regex(\\\"^01[0-9]{7}$\\\");\\n      Console.Write(\\\"Provide a student number: \\\");\\n      string number = Console.ReadLine();\\n\\n      if (regex.IsMatch(number))\\n      {\\n        Console.WriteLine(\\\"Correct format.\\\");\\n      }\\n      else\\n      {\\n        Console.WriteLine(\\\"Incorrect format.\\\");\\n      }\\n    }\\n  }\\n}\\n\")), mdx(\"p\", null, \"Huomannet, ett\\xE4 s\\xE4\\xE4nn\\xF6llinen lauseke alkaa \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://fi.wikipedia.org/wiki/Sirkumfleksi\"\n  }, \"sirkumfleksilla\"), \" ja p\\xE4\\xE4ttyy dollari-merkkiin. Palaamme n\\xE4ihin hetken kuluttua. Ensin k\\xE4ymme l\\xE4pi yleisimm\\xE4t s\\xE4\\xE4nn\\xF6lliset lausekkeet.\"), mdx(\"h3\", {\n    \"id\": \"vaihtoehdot-pystyviiva\"\n  }, \"Vaihtoehdot (pystyviiva)\"), mdx(\"p\", null, \"Pystyviiva tarkoittaa, ett\\xE4 s\\xE4\\xE4nn\\xF6llisen lausekkeen osat ovat valinnaisia. Esimerkiksi \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"00\", \"|\", \"111\", \"|\", \"0000\"), \" m\\xE4\\xE4rittelee merkkijonot 00, 111 ja 0000. \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"IsMatch\"), \"-metodi palauttaa true, jos merkkijono vastaa jotakin m\\xE4\\xE4ritellyist\\xE4 vaihtoehdoista.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"Regex regex = new Regex(\\\"00|111|0000\\\");\\nstring str = \\\"00\\\";\\n\\nif (regex.IsMatch(str))\\n{\\n  Console.WriteLine(\\\"The string contained one of the three alternatives\\\");\\n}\\nelse\\n{\\n  Console.WriteLine(\\\"The string contained none of the alternatives\\\");\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"The string contained one of the three alternatives\\n\")), mdx(\"p\", null, \"S\\xE4\\xE4nn\\xF6llinen lauseke \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"00\", \"|\", \"111\", \"|\", \"0000\"), \" etsii itse asiassa merkkijonosta alimerkkijonoja. T\\xE4m\\xE4kin toimii:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"Regex regex = new Regex(\\\"00|111|0000\\\");\\nstring str = \\\"1111111\\\";\\n\\nif (regex.IsMatch(str))\\n{\\n  Console.WriteLine(\\\"The string contained one of the three alternatives\\\");\\n}\\nelse\\n{\\n  Console.WriteLine(\\\"The string contained none of the alternatives\\\");\\n}\\n\")), mdx(\"p\", null, \"Koska \\\"1111111\\\" sis\\xE4lt\\xE4\\xE4 alimerkkijonon \\\"111\\\", \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"regex.IsMatch\"), \" palauttaa true.\"), mdx(\"h3\", {\n    \"id\": \"merkkijonon-osan-vaikuttaminen-sulkeet\"\n  }, \"Merkkijonon osan vaikuttaminen (sulkeet)\"), mdx(\"p\", null, \"Voit k\\xE4ytt\\xE4\\xE4 sulkeita m\\xE4\\xE4ritt\\xE4\\xE4ksesi mihin osaan s\\xE4\\xE4nn\\xF6llisest\\xE4 lausekkeesta s\\xE4\\xE4nn\\xF6t vaikuttavat. Sanotaan, ett\\xE4 haluamme sallia merkkijonot 00000 ja 00001. Voimme tehd\\xE4 sen laittamalla pystyviivan niiden v\\xE4liin n\\xE4in 00000\", \"|\", \"00001. Sulkeet mahdollistavat vaihtoehdon rajoittamisen tiettyyn merkkijonon osaan. Lauseke 0000(0\", \"|\", \"1) m\\xE4\\xE4rittelee merkkijonot 00000 ja 00001.\"), mdx(\"p\", null, \"Samaan tapaan, s\\xE4\\xE4nn\\xF6llinen lauseke auto(t) m\\xE4\\xE4ritt\\xE4\\xE4 yksi- ja monikkomuodot sanalle auto. Kuitenkin, kun etsimme alimerkkijonoja metodilla \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"IsMatch\"), \", my\\xF6s \\\"autottttttttt\\\" palauttaa true.\"), mdx(\"h3\", {\n    \"id\": \"paljous-ja-lukumäärät\"\n  }, \"Paljous ja lukum\\xE4\\xE4r\\xE4t\"), mdx(\"p\", null, \"Usein halutaan m\\xE4\\xE4ritt\\xE4\\xE4, ett\\xE4 tietty alimerkkijono esiintyy tietyn m\\xE4\\xE4r\\xE4n kertoja. Seuraavat ilmaisut ovat k\\xE4ytett\\xE4viss\\xE4 s\\xE4\\xE4nn\\xF6llisiss\\xE4 lausekkeissa:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"M\\xE4\\xE4re \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"*\"), \" toistaa 0 ... kertaa, esimerkiksi;\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"Regex regex = new Regex(\\\"^trolo(lo)*$\\\");\\nstring str = \\\"trolololololo\\\";\\n\\nif (regex.IsMatch(str))\\n{\\n  Console.WriteLine(\\\"Correct form.\\\");\\n}\\nelse\\n{\\n  Console.WriteLine(\\\"Incorrect form.\\\");\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"Correct form.\\n\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"M\\xE4\\xE4re \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"+\"), \" toistaa 1 ... kertaa, esimerkiksi;\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"Regex regex = new Regex(\\\"^trolo(lo)+$\\\");\\nstring str = \\\"trolololololo\\\";\\n\\nif (regex.IsMatch(str))\\n{\\n  Console.WriteLine(\\\"Correct form.\\\");\\n}\\nelse\\n{\\n  Console.WriteLine(\\\"Incorrect form.\\\");\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"Correct form.\\n\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"M\\xE4\\xE4re \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"?\"), \" toistaa 0 tai 1 kertaa, esimerkiksi;\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"Regex regex = new Regex(\\\"^trolo(lo)?$\\\");\\nstring str = \\\"trololo\\\";\\n\\nif (regex.IsMatch(str))\\n{\\n  Console.WriteLine(\\\"Correct form.\\\");\\n}\\nelse\\n{\\n  Console.WriteLine(\\\"Incorrect form.\\\");\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"Correct form.\\n\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"M\\xE4\\xE4re \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"{a}\"), \" toistaa a kertaa, esimerkiksi;\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"Regex regex = new Regex(\\\"^trolo(lo){3}$\\\");\\nstring str = \\\"trololololo\\\";\\n\\nif (regex.IsMatch(str))\\n{\\n  Console.WriteLine(\\\"Correct form.\\\");\\n}\\nelse\\n{\\n  Console.WriteLine(\\\"Incorrect form.\\\");\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"Correct form.\\n\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"M\\xE4\\xE4re \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"{a,b}\"), \" toistaa a ... b kertaa, esimerkiksi;\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"Regex regex = new Regex(\\\"^trolo(lo){3,6}$\\\");\\nstring str = \\\"trololololololololo\\\";\\n\\nif (regex.IsMatch(str))\\n{\\n  Console.WriteLine(\\\"Correct form.\\\");\\n}\\nelse\\n{\\n  Console.WriteLine(\\\"Incorrect form.\\\");\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"Incorrect form.\\n\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"M\\xE4\\xE4re \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"{a,}\"), \" toistaa a ... kertaa, esimerkiksi;\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"Regex regex = new Regex(\\\"^trolo(lo){3,}$\\\");\\nstring str = \\\"trololololololololo\\\";\\n\\nif (regex.IsMatch(str))\\n{\\n  Console.WriteLine(\\\"Correct form.\\\");\\n}\\nelse\\n{\\n  Console.WriteLine(\\\"Incorrect form.\\\");\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"Correct form.\\n\")), mdx(\"p\", null, \"Voit k\\xE4ytt\\xE4\\xE4 useampaa kuin yht\\xE4 m\\xE4\\xE4rett\\xE4 s\\xE4\\xE4nn\\xF6llisess\\xE4 lausekkeessa. Esimerkiksi s\\xE4\\xE4nn\\xF6llinen lauseke ^5{3}(1\", \"|\", \"0)\", \"*\", \"5{3}$ m\\xE4\\xE4rittelee merkkijonot, jotka alkavat ja loppuvat kolmella viitosella. Niiden v\\xE4liss\\xE4 voi olla rajaton m\\xE4\\xE4r\\xE4 ykk\\xF6si\\xE4 ja nollia.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"Regex regex = new Regex(\\\"^5{3}(1|0)*5{3}$\\\");\\nstring str = \\\"5551101000011010555\\\";\\n\\nif (regex.IsMatch(str))\\n{\\n  Console.WriteLine(\\\"Correct form.\\\");\\n}\\nelse\\n{\\n  Console.WriteLine(\\\"Incorrect form.\\\");\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"Correct form.\\n\")), mdx(\"h3\", {\n    \"id\": \"merkkijonot-hakasulkeet\"\n  }, \"Merkkijonot (hakasulkeet)\"), mdx(\"p\", null, \"Merkkej\\xE4 voidaan k\\xE4ytt\\xE4\\xE4 m\\xE4\\xE4ritt\\xE4m\\xE4\\xE4n tietty\\xE4 osaa merkeist\\xE4 tiiviss\\xE4 muodossa. Merkit suljetaan hakasulkeiden sis\\xE4\\xE4n, ja v\\xE4lit voidaan m\\xE4\\xE4ritt\\xE4\\xE4 v\\xE4liviivalla. Esimerkiksi s\\xE4\\xE4nn\\xF6llinen lauseke \", \"[\", \"145\", \"]\", \" tarkoittaa (1\", \"|\", \"4\", \"|\", \"5) ja \", \"[\", \"2-36-9\", \"]\", \" tarkoittaa (2\", \"|\", \"3\", \"|\", \"6\", \"|\", \"7\", \"|\", \"8\", \"|\", \"9). Vastaavasti merkki \", \"[\", \"a-c\", \"]\", \"*\", \" m\\xE4\\xE4ritt\\xE4\\xE4 s\\xE4\\xE4nn\\xF6llisen lausekkeen, joka vaatii merkkijonon sis\\xE4lt\\xE4v\\xE4n vain a, b ja c.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"Regex regex = new Regex(\\\"[145][2-36-9][a-c]*$\\\");\\nstring str = \\\"49acbc\\\";\\n\\nif (regex.IsMatch(str))\\n{\\n  Console.WriteLine(\\\"Correct form.\\\");\\n}\\nelse\\n{\\n  Console.WriteLine(\\\"Incorrect form.\\\");\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"Correct form.\\n\")), mdx(\"h3\", {\n    \"id\": \"tarkkojen-osumien-etsiminen\"\n  }, \"Tarkkojen osumien etsiminen\"), mdx(\"p\", null, \"Esimerkeiss\\xE4mme kaikki alkoivat \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"^\"), \" ja loppuivat \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"$\"), \" -merkkeihin. N\\xE4ill\\xE4 merkeill\\xE4 on erityinen merkitys s\\xE4\\xE4nn\\xF6llisiss\\xE4 lausekkeissa.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"^ : Alkumerkki. Merkkijonon on aloitettava t\\xE4st\\xE4 merkist\\xE4. Ilman t\\xE4t\\xE4 merkki\\xE4, s\\xE4\\xE4nn\\xF6llinen lauseke voi l\\xF6yty\\xE4 mist\\xE4 tahansa alimerkkijonosta vertailtavasta merkkijonosta.\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"$ : Loppumerkki. Merkkijonon on loputtava t\\xE4h\\xE4n merkkiin. Ilman t\\xE4t\\xE4 merkki\\xE4, merkkijonon loppu voi olla mit\\xE4 tahansa, ja s\\xE4\\xE4nn\\xF6llinen lauseke l\\xF6ytyy silti vertailtavasta merkkijonosta.\"))), mdx(\"h3\", {\n    \"id\": \"säännöllisten-lausekkeiden-kokeileminen\"\n  }, \"S\\xE4\\xE4nn\\xF6llisten lausekkeiden kokeileminen\"), mdx(\"p\", null, \"Tarkan osuman l\\xF6yt\\xE4minen s\\xE4\\xE4nn\\xF6llisill\\xE4 lausekkeilla vaatii hieman harjoittelua. Ei ole mielek\\xE4st\\xE4 kirjoittaa koodiamme uudestaan ja uudestaan, tarkistaaksemme osuuko s\\xE4\\xE4nn\\xF6llinen lauseke. Onneksi internetiss\\xE4 on palveluita, joissa voit kokeilla s\\xE4\\xE4nn\\xF6llisi\\xE4 lausekkeita, kuten \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://www.regextester.com/\"\n  }, \"https://www.regextester.com/\"), \" tai \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://regex101.com/\"\n  }, \"https://regex101.com/\")), mdx(\"h1\", {\n    \"id\": \"tehtävät\"\n  }, \"Teht\\xE4v\\xE4t\"), mdx(Exercise, {\n    title: '004 Regular Expression Checker',\n    mdxType: \"Exercise\"\n  }, mdx(\"p\", null, \"Pohjassa on luokka \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Checker\"), \", jossa on kolme metodia. Teht\\xE4v\\xE4si on t\\xE4ytt\\xE4\\xE4 metodit seuraavasti:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Osa 1: K\\xE4yt\\xE4 s\\xE4\\xE4nn\\xF6llisi\\xE4 lausekkeita \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"DayOfWeek(string str)\"), \" -metodissa, joka palauttaa true, jos parametrina annettu merkkijono on englanninkielinen viikonp\\xE4iv\\xE4n lyhenne (mon, tue, wed, thu, fri, sat, sun)\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Osa 2: K\\xE4yt\\xE4 s\\xE4\\xE4nn\\xF6llisi\\xE4 lausekkeita \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"AllVowels(string str)\"), \" -metodissa, joka palauttaa true, jos kaikki parametrina annetun merkkijonon kirjaimet ovat vokaaleja englanninkieless\\xE4.\"))), mdx(Note, {\n    mdxType: \"Note\"\n  }, \"Yksinkertaisuuden vuoksi, t\\xE4ss\\xE4 teht\\xE4v\\xE4ss\\xE4 vokaaleiksi lasketaan kirjaimet: a, e, i, o, ja u. Sinun ei tarvitse ottaa huomioon isoja kirjaimia, mutta voit jos haluat.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Osa 3: K\\xE4yt\\xE4 s\\xE4\\xE4nn\\xF6llisi\\xE4 lausekkeita \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"TimeOfDay(string str)\"), \" -metodissa, joka palauttaa true, jos parametrina annettu merkkijono on muotoa hh:mm:ss (tunnit, minuutit ja sekunnit, joista jokainen vie kaksi paikkaa).\")), mdx(Note, {\n    mdxType: \"Note\"\n  }, \"Viimeinen on haastava, ja saatat haluta etsi\\xE4 internetist\\xE4 vastauksia.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"Checker check = new Checker();\\n\\nConsole.WriteLine(check.DayOfWeek(\\\"tue\\\"));\\nConsole.WriteLine(check.DayOfWeek(\\\"tues\\\"));\\n\\nConsole.WriteLine(check.AllVowels(\\\"aeiouaaeeioiouoiaoueaiaeiou\\\"));\\nConsole.WriteLine(check.AllVowels(\\\"aeiouaaeeioiouoKiaoueaiaeiou\\\"));\\n\\nConsole.WriteLine(check.TimeOfDay(\\\"23:23:59\\\"));\\nConsole.WriteLine(check.TimeOfDay(\\\"00:00:60\\\"));\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"True\\nFalse\\nTrue\\nFalse\\nTrue\\nFalse\\n\"))));\n}\n;\nMDXContent.isMDXComponent = true;","tableOfContents":{"items":[{"url":"#stringbuilder-ja-säännölliset-lausekkeet-regex","title":"StringBuilder ja Säännölliset lausekkeet (RegEx)","items":[{"url":"#stringbuilder","title":"StringBuilder"},{"url":"#säännölliset-lausekkeet-regex","title":"Säännölliset lausekkeet, Regex","items":[{"url":"#vaihtoehdot-pystyviiva","title":"Vaihtoehdot (pystyviiva)"},{"url":"#merkkijonon-osan-vaikuttaminen-sulkeet","title":"Merkkijonon osan vaikuttaminen (sulkeet)"},{"url":"#paljous-ja-lukumäärät","title":"Paljous ja lukumäärät"},{"url":"#merkkijonot-hakasulkeet","title":"Merkkijonot (hakasulkeet)"},{"url":"#tarkkojen-osumien-etsiminen","title":"Tarkkojen osumien etsiminen"},{"url":"#säännöllisten-lausekkeiden-kokeileminen","title":"Säännöllisten lausekkeiden kokeileminen"}]}]},{"url":"#tehtävät","title":"Tehtävät"}]},"frontmatter":{"title":"Merkkijonojen käsittely"}}},"pageContext":{"id":"2600522f-3e2f-596f-94b0-4dbe00219152"}},
    "staticQueryHashes": ["1885717130","1950529541","2744905544","3020054368"]}