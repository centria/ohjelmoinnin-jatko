{
    "componentChunkName": "component---src-templates-docs-js",
    "path": "/osa07/osa07-2",
    "result": {"data":{"mdx":{"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Johdanto testaukseen\",\n  \"nav_order\": 72,\n  \"hidden\": false\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar Note = makeShortcode(\"Note\");\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"testaaminen\"\n  }, \"Testaaminen\"), mdx(\"p\", null, \"\\xC4sken tutustuimme lyhyesti testaamiseen, mutta emme oikeastaan selitt\\xE4neet mit\\xE4 teimme. Otetaan ensimm\\xE4iset askeleet ohjelmien testaamisen maailmaan.\"), mdx(\"h2\", {\n    \"id\": \"virhetilanteet-ja-ongelmanratkaisu-askel-askeleelta\"\n  }, \"Virhetilanteet ja ongelmanratkaisu askel askeleelta\"), mdx(\"p\", null, \"Kirjoittamiimme ohjelmiin p\\xE4\\xE4tyy virheit\\xE4. Joskus virheet eiv\\xE4t ole vakavia ja aiheuttavat p\\xE4\\xE4asiassa p\\xE4\\xE4nvaivaa ohjelman k\\xE4ytt\\xE4jille. Toisinaan taas virheet voivat johtaa hyvinkin vakaviin seurauksiin. Joka tapauksessa on varmaa, ett\\xE4 ohjelmointia opetteleva tekee paljon virheit\\xE4.\"), mdx(\"p\", null, \"\\xC4l\\xE4 koskaan pelk\\xE4\\xE4 tai v\\xE4lttele virheiden tekemist\\xE4, sill\\xE4 virheet ovat paras tapa oppia. T\\xE4st\\xE4 syyst\\xE4 kannattaa yritt\\xE4\\xE4 rikkoa ohjelma jota ty\\xF6st\\xE4\\xE4 aika ajoin, jotta n\\xE4kee mit\\xE4 virheilmoituksia ohjelma antaa ja mit\\xE4 ne kertovat virheist\\xE4.\"), mdx(\"p\", null, \"Raportti osoitteessa \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"http://sunnyday.mit.edu/accidents/MCO_report.pdf\"\n  }, \"http://sunnyday.mit.edu/accidents/MCO_report.pdf\"), \" kertoo vakavammasta ohjelmointivirheest\\xE4 ja virheen syyst\\xE4.\"), mdx(\"p\", null, \"Virhe, tunnetaan my\\xF6s nimell\\xE4 bugi, johtui siit\\xE4, ett\\xE4 ohjelma oletti ohjelmoijan k\\xE4ytt\\xE4v\\xE4n \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://fi.wikipedia.org/wiki/SI-j%C3%A4rjestelm%C3%A4\"\n  }, \"SI-j\\xE4rjestelm\\xE4\\xE4\"), \" (metrit, kilogrammat, ...) laskuissa. Ohjelmoija oli kuitenkin k\\xE4ytt\\xE4nyt joissain laskuissa \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://fi.wikipedia.org/wiki/Yhdysvaltain_mittayksikk%C3%B6j%C3%A4rjestelm%C3%A4\"\n  }, \"Yhdysvaltain mittayksikk\\xF6j\\xE4rjestelm\\xE4\\xE4\"), \", joka esti satelliittinavigoinnin automaattisen korjausj\\xE4rjestelm\\xE4n toiminnan.\"), mdx(\"p\", null, \"Satelliitti tuhoutui.\"), mdx(\"p\", null, \"Kun ohjelmiston kompleksisuus kasvaa, virheiden l\\xF6yt\\xE4minen vaikeutuu. Visual Studio Codeen integroitu debugger voi auttaa virheiden l\\xF6yt\\xE4misess\\xE4, ja sen k\\xE4ytt\\xE4miseen l\\xF6ytyy selke\\xE4t englannikieliset ohjeet t\\xE4\\xE4lt\\xE4: \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://code.visualstudio.com/docs/editor/debugging\"\n  }, \"https://code.visualstudio.com/docs/editor/debugging\"), \".\"), mdx(\"h2\", {\n    \"id\": \"kutsupino\"\n  }, \"Kutsupino\"), mdx(\"p\", null, \"Kun ohjelmassa ilmenee virhe, ohjelma tulostaa tyypillisesti jotain, jota kutsutaan kutsupinoksi eli \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://en.wikipedia.org/wiki/Stack_trace\"\n  }, \"stack traceksi\"), \". Kutsupino on lista metodikutsuja, jotka johtivat virheeseen. Esimerkiksi kutsupino voi n\\xE4ytt\\xE4\\xE4 t\\xE4lt\\xE4:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"Program.cs(13,46): error CS1002: ; expected [/mnt/c/Users/HeikkiHei/Documents/coding-exercises/project_examples/NewTypes/src/NewTypes/NewTypes.csproj]\\n\\nThe build failed. Fix the build errors and run again.\\n\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Virheellinen tiedosto on ensimm\\xE4isen\\xE4, \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Program.cs\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Sitten virheen sijainti, jos mahdollista \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"(rivill\\xE4 13, merkiss\\xE4 46)\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Virhekoodi \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"CS1002\"), \", joka kertoo mik\\xE4 virhe on kyseess\\xE4\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Tiedoston tarkka sijainti\")), mdx(\"p\", null, \"Saamme t\\xE4m\\xE4n kutsupinon poistamalla yhden puolipisteen Pets-esimerkist\\xE4mme.\"), mdx(\"h2\", {\n    \"id\": \"ongelmanratkaisun-tarkistuslista\"\n  }, \"Ongelmanratkaisun tarkistuslista\"), mdx(\"p\", null, \"Jos koodisi ei toimi ja et tied\\xE4 miss\\xE4 virhe on, n\\xE4m\\xE4 askeleet auttavat sinua p\\xE4\\xE4sem\\xE4\\xE4n alkuun.\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Sisenn\\xE4 koodisi kunnolla ja tarkista, ett\\xE4 sulkeet ovat kunnossa ja kaikki paikallaan.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Tarkista, ett\\xE4 k\\xE4ytt\\xE4m\\xE4si muuttujat on nimetty oikein.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Kokeile ohjelman kulkua eri sy\\xF6tteill\\xE4 ja selvit\\xE4 millainen sy\\xF6te aiheuttaa ohjelman toimimattomuuden. Jos sait virheen testeiss\\xE4, ne voivat my\\xF6s kertoa k\\xE4ytetyn sy\\xF6tteen.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Lis\\xE4\\xE4 ohjelmaan tulostuskomentoja, joilla tulostat ohjelman suorituksen eri vaiheissa k\\xE4ytettyjen muuttujien arvot.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Varmista, ett\\xE4 kaikki k\\xE4ytt\\xE4m\\xE4si muuttujat on alustettu. Jos niit\\xE4 ei ole alustettu, ohjelma kaatuu NullPointerException-virheeseen.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Jos ohjelmasi aiheuttaa poikkeuksen, kiinnit\\xE4 huomiota poikkeuksen mukana tulevaan kutsupinoon, joka kertoo miss\\xE4 virhe on.\")), mdx(\"h2\", {\n    \"id\": \"syötteen-antaminen-testaamiseen\"\n  }, \"Sy\\xF6tteen antaminen testaamiseen\"), mdx(\"p\", null, \"Manuaalisesti testaaminen on usein ty\\xF6l\\xE4st\\xE4. On mahdollista automatisoida sy\\xF6tteen antaminen esimerkiksi luomalla \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://docs.microsoft.com/en-us/dotnet/api/system.io.stringreader?view=net-6.0\"\n  }, mdx(\"strong\", {\n    parentName: \"a\"\n  }, \"StringReader\")), \" ja antamalla sen sis\\xE4lt\\xF6 \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://docs.microsoft.com/en-us/dotnet/api/system.console.setin?view=net-6.0\"\n  }, mdx(\"strong\", {\n    parentName: \"a\"\n  }, \"Console.SetIn\")), \" -metodille. Alla on esimerkki siit\\xE4, miten ohjelmaa voidaan testata automaattisesti. Ohjelmaan sy\\xF6tet\\xE4\\xE4n ensin viisi merkkijonoa, jonka j\\xE4lkeen sy\\xF6tet\\xE4\\xE4n aiemmin n\\xE4hty merkkijono. T\\xE4m\\xE4n j\\xE4lkeen yritet\\xE4\\xE4n sy\\xF6tt\\xE4\\xE4 uusi merkkijono. Merkkijonoa \\\"six\\\" ei pit\\xE4isi l\\xF6yty\\xE4 sanajoukosta.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"using System;\\nusing System.IO;\\nusing System.Collections.Generic;\\n\\n\\nnamespace Exercise001\\n{\\n  class Program\\n  {\\n    static void Main(string[] args)\\n    {\\n      string input = \\\"one\\\\n\\\" + \\\"two\\\\n\\\" +\\n                      \\\"three\\\\n\\\" + \\\"four\\\\n\\\" +\\n                      \\\"five\\\\n\\\" + \\\"one\\\\n\\\" +\\n                      \\\"six\\\\n\\\";\\n      StringReader reader = new StringReader(input);\\n\\n      List<string> read = new List<string>();\\n\\n      while (true)\\n      {\\n        Console.WriteLine(\\\"Enter an input: \\\");\\n        // Ohjataan konsolin sy\\xF6te lukijaan\\n        Console.SetIn(reader);\\n        // Se on nyt muistissa ja annetaan ReadLine:lle\\n        // Jokainen rivinvaihto \\\"\\\\n\\\" aloittaa uuden rivin\\n        // Antaen ReadLine:lle kuusi sy\\xF6tett\\xE4\\n        string line = Console.ReadLine();\\n        // jos sy\\xF6te on jo luettu, lopetetaan\\n        if (read.Contains(line))\\n        {\\n          break;\\n        }\\n\\n        read.Add(line);\\n      }\\n\\n      Console.WriteLine(\\\"Thank you!\\\");\\n\\n      if (read.Contains(\\\"six\\\"))\\n      {\\n        Console.WriteLine(\\\"A value that should not have been added to the group was added to it.\\\");\\n      }\\n    }\\n  }\\n}\\n\")), mdx(\"p\", null, \"Ohjelman tuloste n\\xE4ytt\\xE4\\xE4 vain ohjelman antamat sy\\xF6tteet, eik\\xE4 k\\xE4ytt\\xE4j\\xE4n antamia sy\\xF6tteit\\xE4. \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"Enter an input:\\nEnter an input:\\nEnter an input:\\nEnter an input:\\nEnter an input:\\nEnter an input:\\nThank you!\\n\")), mdx(\"p\", null, \"Antamalla merkkijonon luokan \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"StringReader\"), \" konstruktorille korvataan n\\xE4pp\\xE4imist\\xF6lt\\xE4 luettava sy\\xF6te. T\\xE4ll\\xF6in merkkijonon input sis\\xE4lt\\xF6 \\\"simuloi\\\" k\\xE4ytt\\xE4j\\xE4n sy\\xF6tett\\xE4. Rivinvaihto merkataan sy\\xF6tteess\\xE4 \\\\n. T\\xE4m\\xE4n vuoksi merkkijonon input annetussa sy\\xF6tteess\\xE4 kunkin rivin lopussa vastaa yht\\xE4 ReadLine-komennolle annettua sy\\xF6tett\\xE4.\"), mdx(\"p\", null, \"Kun ohjelmaa testataan uudelleen manuaalisesti, poistetaan tai kommentoidaan rivi \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Console.SetIn(reader);\"), \". Vaihtoehtoisesti voit my\\xF6s muuttaa testisy\\xF6tett\\xE4, sill\\xE4 k\\xE4sittelemme merkkijonoja.\"), mdx(\"h2\", {\n    \"id\": \"yksikkötestaus\"\n  }, \"Yksikk\\xF6testaus\"), mdx(\"p\", null, \"Yll\\xE4 hahmoteltu automaattinen testausmenetelm\\xE4, jossa ohjelman sy\\xF6tett\\xE4 muokataan, on varsin k\\xE4tev\\xE4, mutta silti rajallinen. Suurempien ohjelmien testaaminen t\\xE4ll\\xE4 tavalla on haastavaa. Yksi ratkaisu t\\xE4h\\xE4n on yksikk\\xF6testaus, jossa ohjelman pieni\\xE4 osia testataan erill\\xE4\\xE4n.\"), mdx(\"p\", null, \"Yksikk\\xF6testaus viittaa l\\xE4hdekoodin yksitt\\xE4isten komponenttien, kuten luokkien ja niiden tarjoamien metodien testaamiseen. Testien kirjoittaminen paljastaa, noudattaako jokainen metodi ja luokka ohjeistusta siit\\xE4, ett\\xE4 kullakin metodilla ja luokalla on yksi selke\\xE4 vastuu. Mit\\xE4 enemm\\xE4n vastuuta metodilla on, sit\\xE4 monimutkaisemmaksi testaaminen muuttuu. Jos suuri sovellus on kirjoitettu yhteen metodiin, sen testaaminen on eritt\\xE4in haastavaa, ellei mahdotonta. Vastaavasti, jos sovellus on jaettu selkeisiin luokkiin ja metodeihin, testien kirjoittaminen on suoraviivaista.\"), mdx(\"p\", null, \"Valmiita yksikk\\xF6testikirjastoja (englanniksi unit test libraries) k\\xE4ytet\\xE4\\xE4n usein testien kirjoittamisessa, jotka tarjoavat metodeja ja apuluokkia testien kirjoittamiseen. Yksi laajasti k\\xE4ytetyist\\xE4 testikirjastoista C#:ssa on \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://xunit.net/\"\n  }, mdx(\"strong\", {\n    parentName: \"a\"\n  }, \"xUnit\")), \", jota olemme jo k\\xE4ytt\\xE4neet harjoituksissamme.\"), mdx(\"p\", null, \"Katsotaan tarkemmin yksikk\\xF6testien kirjoittamista esimerkin avulla. Oletetaan, ett\\xE4 meill\\xE4 on seuraava Calculator-luokka, jolle haluamme kirjoittaa automaattisia testej\\xE4.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"public class Calculator\\n{\\n\\n  public int value { get; private set; }\\n\\n  public Calculator()\\n  {\\n    this.value = 0;\\n  }\\n\\n  public void Sum(int number)\\n  {\\n    this.value = this.value + number;\\n  }\\n\\n  public void Substract(int number)\\n  {\\n    this.value = this.value + number;\\n  }\\n}\\n\")), mdx(\"p\", null, \"Laskin toimii aina muistamalla edellisen laskutoimituksen tuloksen. Kaikki seuraavat laskutoimitukset lis\\xE4t\\xE4\\xE4n aina edelliseen tulokseen. Laskimessa on copy-pasten takia pieni virhe, joka on j\\xE4\\xE4nyt laskimeen. Metodin substract pit\\xE4isi v\\xE4hent\\xE4\\xE4 arvoa, mutta se lis\\xE4\\xE4 sen t\\xE4ll\\xE4 hetkell\\xE4.\"), mdx(\"p\", null, \"Yksikk\\xF6testien kirjoittaminen alkaa testiluokan luomisella, joka luodaan Test-kansion alle. Kun testataan \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Calculator\"), \"-luokkaa, testiluokan nimi on \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"CalculatorTests\"), \".\"), mdx(\"p\", null, \"Testiluokka \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"CalculatorTest\"), \" on aluksi varsin antelias, sill\\xE4 se ei itseasiassa testaa mit\\xE4\\xE4n:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"using System;\\nusing Xunit;\\n\\nnamespace CalculatorTest\\n{\\n    public class UnitTest1\\n    {\\n        [Fact]\\n        public void Test1()\\n        {\\n\\n        }\\n    }\\n}\\n\")), mdx(\"p\", null, \"K\\xE4yd\\xE4\\xE4n tiedosto l\\xE4pi:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Se kuuluu nimiavaruuteen CalculatorTest\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Siin\\xE4 on luokka \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"UnitTest1\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Rivi \", \"[\", \"Fact\", \"]\", \" osoittaa, ett\\xE4 seuraava metodi on testi. \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"T\\xE4m\\xE4 rivi on pakollinen dotnet testille\"), \", jotta seuraava metodi tunnistetaan testiksi.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Testimetodi on nimelt\\xE4\\xE4n \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Test1\"), \". Se on tyhj\\xE4 ja aina l\\xE4p\\xE4isee.\")), mdx(Note, {\n    mdxType: \"Note\"\n  }, \"Muista lis\\xE4t\\xE4 p\\xE4\\xE4projektiin viittaus!\"), mdx(\"p\", null, \"Testit ovat metodeita testiluokassa, joissa jokainen testi testaa yksitt\\xE4ist\\xE4 yksikk\\xF6\\xE4. Aloittakaamme testiluokan luominen -- aloitamme luomalla testimetodin, joka varmistaa, ett\\xE4 uuden laskimen arvo on aluksi 0.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"using System;\\nusing Xunit;\\nusing Calculators;\\n\\nnamespace CalculatorTest\\n{\\n    public class UnitTest1\\n    {\\n        [Fact]\\n        public void CalculatorInitialValueZero()\\n        {\\n            Calculator calculator = new Calculator();\\n            Assert.Equal(0, calculator.value);\\n        }\\n    }\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"dotnet test \\n\\n[. . .]\\n\\nStarting test execution, please wait...\\nA total of 1 test files matched the specified pattern.\\n\\nPassed!  - Failed:     0, Passed:     1, Skipped:     0, Total:     1, Duration: < 1 ms\\n\")), mdx(\"p\", null, \"Annoimme testille merkityksellisemm\\xE4n nimen.\"), mdx(\"p\", null, \"Metodissa \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"CalculatorInitialValueZero\"), \" luodaan ensin laskin-olio. \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Assert.Equal\"), \"-metodi, jota xUnit-testikehys tarjoaa, tarkistaa sitten arvon. Metodi tuodaan xUnit Frameworkista \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"using xUnit;\"), \" ja sille annetaan odotettu arvo parametrina -- t\\xE4ss\\xE4 tapauksessa 0 -- ja laskimen palauttama arvo. Jos \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Assert.Equal\"), \"-metodin arvot eroavat, testi ei l\\xE4p\\xE4ise. Jokaisella testimetodilla pit\\xE4isi olla \\\"annotaatio\\\" \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"[\", \"Fact\", \"]\"), \". T\\xE4m\\xE4 kertoo xUnit-testikehykselle, ett\\xE4 t\\xE4m\\xE4 on suoritettava testimetodi.\"), mdx(\"p\", null, \"Lis\\xE4t\\xE4\\xE4n toiminnalisuus summaamisen ja v\\xE4hent\\xE4misen testaamiseen.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"using Xunit;\\nusing Calculators;\\n\\nnamespace CalculatorTest\\n{\\n  public class Tests\\n  {\\n    [Fact]\\n    public void CalculatorInitialValueZero()\\n    {\\n      Calculator calculator = new Calculator();\\n      Assert.Equal(0, calculator.value);\\n    }\\n\\n    [Fact]\\n    public void ValueFiveWhenFiveAdded()\\n    {\\n      Calculator calculator = new Calculator();\\n      calculator.Sum(5);\\n      Assert.Equal(5, calculator.value);\\n    }\\n\\n    [Fact]\\n    public void ValueMinusTwoWhenTwoSubstracted()\\n    {\\n      Calculator calculator = new Calculator();\\n      calculator.Substract(2);\\n      Assert.Equal(-2, calculator.value);\\n    }\\n  }\\n}\\n\")), mdx(\"p\", null, \"Testien suorittaminen tuottaa seuraavan tuloksen.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"dotnet test\\n\\nStarting test execution, please wait...\\nA total of 1 test files matched the specified pattern.\\n[xUnit.net 00:00:00.37]     CalculatorTest.Tests.ValueMinusTwoWhenTwoSubstracted [FAIL]\\n  Failed CalculatorTest.Tests.ValueMinusTwoWhenTwoSubstracted [1 ms]\\n  Error Message:\\n   Assert.Equal() Failure\\nExpected: -2\\nActual:   2\\n  Stack Trace:\\n     at CalculatorTest.Tests.ValueMinusTwoWhenTwoSubstracted() in [. . .]Calculators/test/CalculatorTest/UnitTest1.cs:line 28\\n\\nFailed!  - Failed:     1, Passed:     2, Skipped:     0, Total:     3, Duration: 19 ms\\n\")), mdx(\"p\", null, \"Tuloste kertoo, ett\\xE4 kolme testi\\xE4 suoritettiin. Yksi niist\\xE4 ep\\xE4onnistui. Testituloste kertoo my\\xF6s rivin, jossa virhe tapahtui (28), ja odotetun (-2) ja todellisen (2) arvon. Aina kun testien suoritus p\\xE4\\xE4ttyy virheeseen, testikehys n\\xE4ytt\\xE4\\xE4 my\\xF6s virhetilan visuaalisesti.\"), mdx(\"p\", null, \"Edellisist\\xE4 testeista kaksi l\\xE4p\\xE4isi, mutta yksi ep\\xE4onnistui. Korjataan virhe joka on j\\xE4\\xE4nyt laskimeen.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"// ...\\npublic void Substract(int number)\\n{\\n  this.value -= number;\\n}\\n// ...\\n\")), mdx(\"p\", null, \"Kun testit ajetaan uudelleen, ne menev\\xE4t l\\xE4pi.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"dotnet test \\n\\n[. . .]\\n\\nStarting test execution, please wait...\\nA total of 1 test files matched the specified pattern.\\n\\nPassed!  - Failed:     0, Passed:     3, Skipped:     0, Total:     3, Duration: 2 ms\\n\")), mdx(\"p\", null, \"Yksikk\\xF6testaaminen on eritt\\xE4in monimutkaista, jos koko sovellus on kirjoitettu \\\"Main\\\"-metodiin. Testaaminen on helpompaa, jos sovellus on jaettu pieniin osiin, joilla on selke\\xE4 vastuu. Aiemmissa osioissa harjoittelimme t\\xE4t\\xE4, kun erottelimme k\\xE4ytt\\xF6liittym\\xE4n sovelluslogiikasta ja loimme selke\\xE4n kansiorakenteen. Testien kirjoittaminen sovelluksen osille, kuten edellisess\\xE4 osiossa n\\xE4htyyn \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Pets\"), \"-luokkaan, on huomattavasti helpompaa kuin testien kirjoittaminen \\\"Main\\\"-metodille kokonaisuudessaan.\"), mdx(\"h2\", {\n    \"id\": \"testivetoinen-kehitys\"\n  }, \"Testivetoinen kehitys\"), mdx(\"p\", null, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://fi.wikipedia.org/wiki/Testivetoinen_kehitys\"\n  }, mdx(\"strong\", {\n    parentName: \"a\"\n  }, \"Testivetoinen kehitys\")), \" (tai englanniksi\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://en.wikipedia.org/wiki/Test-driven_development\"\n  }, mdx(\"strong\", {\n    parentName: \"a\"\n  }, \"Test-driven development\")), \")  on ohjelmistokehitt\\xE4misen prosessi joka perustuu ohjelmiston rakentamiseen pieniss\\xE4 iteraatioissa. Testivetoinen ohjelmistokehitys tarkoittaa, ett\\xE4 ohjelmoija kirjoittaa aina ensimm\\xE4iseksi automaattisesti suoritettavan testin, joka testaa yht\\xE4 tietty\\xE4 tietokoneohjelman osaa.\"), mdx(\"p\", null, \"Testi ei mene l\\xE4pi, koska testin vaatimukset t\\xE4ytt\\xE4v\\xE4\\xE4 toiminnallisuutta, eli tietokoneohjelman osaa, ei ole viel\\xE4 olemassa. Kun testi on kirjoitettu, lis\\xE4t\\xE4\\xE4n ohjelmaan toiminnallisuus, joka t\\xE4ytt\\xE4\\xE4 testin vaatimukset. Testit ajetaan uudelleen. Jos kaikki testit menev\\xE4t l\\xE4pi, lis\\xE4t\\xE4\\xE4n uusi testi, tai jos testit eiv\\xE4t mene l\\xE4pi, korjataan jo kirjoitettua ohjelmaa. Tarvittaessa ohjelman sis\\xE4ist\\xE4 rakennetta korjataan tai refaktoroidaan, jotta ohjelman toiminnallisuus pysyy samana, mutta rakenne selkeytyy.\"), mdx(\"p\", null, \"Testivetoinen ohjelmistokehitys koostuu viidest\\xE4 vaiheesta, jotka toistetaan kunnes ohjelman toiminnallisuus on valmis.\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Kirjoita testi. Ohjelmoija p\\xE4\\xE4tt\\xE4\\xE4, mit\\xE4 ohjelman toiminnallisuutta testataan ja kirjoittaa sille testin.\")), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Suorita testit ja tarkista, ett\\xE4 testit menev\\xE4t l\\xE4pi. Kun uusi testi on kirjoitettu, testit ajetaan. Jos testi menee l\\xE4pi, testi on todenn\\xE4k\\xF6isesti virheellinen ja sit\\xE4 pit\\xE4isi korjata -- testin pit\\xE4isi testata vain toiminnallisuutta, jota ei ole viel\\xE4 toteutettu.\")), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Kirjoita toiminnallisuus, joka t\\xE4ytt\\xE4\\xE4 testin vaatimukset. Ohjelmoija toteuttaa toiminnallisuuden, joka t\\xE4ytt\\xE4\\xE4 vain testin vaatimukset. Huomaa: t\\xE4t\\xE4 ei tehd\\xE4 lis\\xE4\\xE4m\\xE4ll\\xE4 toiminnallisuutta, jota testi ei vaadi -- toiminnallisuutta lis\\xE4t\\xE4\\xE4n vain pienin askelin.\")), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Suorita testit. Jos testit eiv\\xE4t mene l\\xE4pi, on todenn\\xE4k\\xF6ist\\xE4, ett\\xE4 toiminnallisuus on virheellinen. Korjaa toiminnallisuus -- tai jos toiminnallisuudessa ei ole virheit\\xE4, korjaa viimeisin suoritettu testi.\")), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Korjaa ohjelman sis\\xE4inen rakenne. Kun ohjelman koko kasvaa, sen sis\\xE4ist\\xE4 rakennetta muokataan tarpeen mukaan. Liian pitk\\xE4t metodit pilkotaan pienempiin osiin ja k\\xE4sitteit\\xE4 edustavat luokat eristet\\xE4\\xE4n. Testej\\xE4 ei muokata, vaan niit\\xE4 k\\xE4ytet\\xE4\\xE4n ohjelman sis\\xE4isen rakenteen muutosten oikeellisuuden varmistamiseen -- jos ohjelman rakenteen muuttaminen muuttaa ohjelman toiminnallisuutta, testit antavat varoituksen ja ohjelmoija voi korjata tilanteen.\"))), mdx(\"p\", null, \"Huomannet, ett\\xE4 t\\xE4m\\xE4 toimii samaan tapaan kuin teht\\xE4vien tekeminen: testit ovat olemassa ja odottavat sinun luovan ohjelman, joka toimii testien vaatimalla tavalla.\"), mdx(\"p\", null, \"Yksikk\\xF6testaus on vain osa ohjelmistotestausta. Yksittl\\xF6testauksen lis\\xE4ksi ohjelmoija tekee integraatiotestausta varmistaakseen ohjelman osien yhteentoimivuuden, kuten luokkiemme ja metodiemme. Lis\\xE4ksi ohjelmoija tekee k\\xE4ytt\\xF6liittym\\xE4testausta varmistaakseen, ett\\xE4 ohjelman k\\xE4ytt\\xF6liittym\\xE4 toimii odotetulla tavalla.\"), mdx(\"h1\", {\n    \"id\": \"tehtävät\"\n  }, \"Teht\\xE4v\\xE4t\"), mdx(Note, {\n    mdxType: \"Note\"\n  }, \"Ei teht\\xE4vi\\xE4 t\\xE4ss\\xE4 osiossa.\"));\n}\n;\nMDXContent.isMDXComponent = true;","tableOfContents":{"items":[{"url":"#testaaminen","title":"Testaaminen","items":[{"url":"#virhetilanteet-ja-ongelmanratkaisu-askel-askeleelta","title":"Virhetilanteet ja ongelmanratkaisu askel askeleelta"},{"url":"#kutsupino","title":"Kutsupino"},{"url":"#ongelmanratkaisun-tarkistuslista","title":"Ongelmanratkaisun tarkistuslista"},{"url":"#syötteen-antaminen-testaamiseen","title":"Syötteen antaminen testaamiseen"},{"url":"#yksikkötestaus","title":"Yksikkötestaus"},{"url":"#testivetoinen-kehitys","title":"Testivetoinen kehitys"}]},{"url":"#tehtävät","title":"Tehtävät"}]},"frontmatter":{"title":"Johdanto testaukseen"}}},"pageContext":{"id":"3e99195c-165b-5e9d-a530-ae1e4a2f7670"}},
    "staticQueryHashes": ["1885717130","1950529541","2744905544","3020054368"]}